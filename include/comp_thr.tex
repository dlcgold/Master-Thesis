\subsection{Componente per le threshold}
Come discusso per MONI per la $\RLBWT$, l'uso delle threshold è 
uno dei due modi per computare l'array delle matching statistics. \\
\begin{definizione}
  Data la colonna $k$-esima della matrice $\PBWT$, $y^k$, memorizzata
  tramite compressione run-length e data la run $j$-esima, indicizzata
  da $i$ a $i'$, si definisce threshold come l'indice del minimo valore
  dell'$\,\RLCP$,
  compreso negli indici della run, considerando anche l'eventuale 
  $\RLCP_k[i'+1]$, qualora $i'\neq M-1$. Si noti che quest'ultimo valore, se
  esistente, deve essere considerato in quanto calcolato prendendo in
  considerazione $y^k_{i'}$ (valore appartenente alla run in analisi) e
  $y^k_{i'+1}$. \\
  Qualora si abbiano più valori minimi uguali in $\RLCP_k$ si seleziona il primo
  per convenzione.
\end{definizione}
Da un punto di vista implementativo, come anticipato, si hanno due soluzioni,
una basata su intvector compressi e una basata su bitvector sparsi. In
entrambi i casi il calcolo si può effettuare in parallelo a quello delle
componenti \texttt{MAP-INT} e \texttt{MAP-BV}.
\subsubsection{Threshold con intvector compressi}
Con questa componente, la memorizzazione delle threshold avviene in modo molto
semplice, 
usando un vettore di interi bit-compressed. Data una colonna $k$ della
matrice $\PBWT$, con $r$ numero di run, si calcola $t_k$ tale che
$t_k[i]=j$ sse $j$ è l'indice della threshold dell'$i$-esima run.\\
Lo pseudocodice per la costruzione della componente
\texttt{THR-INT} della colonna $k$ è consultabile all'algoritmo
\ref{algo:thrint} 
e, dovendo scorrere la colonna permutata dal prefix array $a_k$ e dovendo
accedere ai valori di $l_k$, tale operazione ha complessità in tempo
proporzionale a:
\begin{equation}
  \label{eq:thrint}
  \mathcal{O}(M)
\end{equation}
Si noti che, qualora minimo $\RLCP$ si trovi nella testa della run successiva
(da considerare in quanto calcolato anche grazie all'ultimo elemento della run
corrente), si memorizza l'indice della testa della run
successiva come threshold.
\begin{algorithm}
  \begin{algorithmic}
    \Function{Build\_thr\_int}{$col,\,\,pref,\,\,div$}
    \Comment $pref=a_k,\,\,div=l_k$
    \State $curr_{lcs}\gets 0,\,\,tmp_{thr}\gets 0$
    \State $t\gets[]$
    \For {\textit{every} $k\in\left[0,\,\, M\right)$}
    \If{$k=0\lor col[pref[k]]\neq col[pref[k-1]]$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$div[k]<curr_{lcs}$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$k=M-1\lor col[pref[k]]\neq col[pref[k+1]]$}
    \If{$k\neq M-1\land div[k+1]<div[tmp_{thr}]$}
    \State $push(t, k+1)$
    \Else 
    \State $push(t, tmp_{thr})$
    \EndIf
    \EndIf
    \EndFor
    \State \textbf{return} $t$  
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per la costruzione della componente \texttt{THR-INT}.}
  \label{algo:thrint}
\end{algorithm}
\subsubsection{Threshold con bitvector}
Con questa componente, le posizioni delle threshold vengono
memorizzate, per ogni colonna $k$, tramite un bitvector sparso, denotato
$thr_k$, avendo che $thr_k[i]=1$ sse $i$ è l'indice di una threshold.
Qualora il minimo $\RLCP$ si trovi nell'indice della testa della run
successiva, la posizione della threshold verrà memorizzata all'indice
della coda della run corrente. Purtroppo questa è una situazione di ambiguità.
Infatti, come si vedrà poi durante lo studio dell'algoritmo di calcolo delle
matching statistics tramite threshold, il fatto che una threshold posta a fine
run corrisponda effettivamente ad un minimo $\RLCP$ in quella posizione o a
quella successiva comporta differenze dal punto di vista del calcolo dell'array
$\MS$. 
Purtroppo, non è possibile salvare la threshold direttamente nella testa della
run successiva in quanto questa potrebbe essere anche la posizione della
threshold della run successiva e avere due threshold sovrapposte impedirebbe di
capire a quale run appartiene una certa threshold, tramite la funzione
$\rank$. \\
Lo pseudocodice per la costruzione della componente
\texttt{THR-BV} della colonna $k$ è consultabile all'algoritmo \ref{algo:thrbv}
e, dovendo scorrere la colonna permutata dal prefix array $a_k$ e dovendo
accedere ai valori di $l_k$, tale operazione ha complessità in tempo
proporzionale a:
\begin{equation}
  \label{eq:thrbv}
  \mathcal{O}(M)
\end{equation}
\begin{algorithm}
  \begin{algorithmic}
    \Function{Build\_thr\_bv}{$col,\,\,pref,\,\,div$}
    \Comment $pref=a_k,\,\,div=l_k$
    \State $curr_{lcs}\gets 0,\,\,tmp_{thr}\gets 0$
    \State $thrs\gets[0..0]$
    \Comment bitvector sparso di lunghezza $M$
    \For {\textit{every} $k\in\left[0,\,\, M\right)$}
    \If{$k=0\lor col[pref[k]]\neq col[pref[k-1]]$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$div[k]<curr_{lcs}$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$k=M-1\lor col[pref[k]]\neq col[pref[k+1]]$}
    \If{$k\neq M-1\land div[k+1]<div[tmp_{thr}]$}
    \State $thrs[k]\gets 1$
    \Else
    \State $thrs[tmp_{thr}]\gets 1$
    \EndIf
    \EndIf
    \EndFor
    \State \textit{costruzione delle strutture $\rank$/$\select$ per thr}
    \State \textbf{return} $thr$  
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per la costruzione della componente \texttt{THR-BV}.}
  \label{algo:thrbv}
\end{algorithm}
\noindent
In merito al confronto tra \texttt{THR-INT} e \texttt{THR-BV}, in termini di uso
di memoria, valgono le stesse considerazioni fatte per le componenti di mapping.
\dc{Serve ridire quanto pesa un bv?}