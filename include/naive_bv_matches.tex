\section{Algoritmo per il calcolo degli SMEM}
Avendo presentato le prime due varianti della \textbf{RLPBWT}, è possibile
discutere 
dell'algoritmo degli \textit{SMEM} con un aplotipo esterno, che riprende
esattamente quanto discusso nell'algoritmo 5 di Durbin. Tale algoritmo, di
fatto, non sfrutta l'uso delle matching statistics ed è limitato dal non poter
calcolare quali righe presentano un solo SMEM, calcolando solo quante siano.\\
Il metodo procede quindi con l'aggiornamento dei tre indici $e_k$, $f_k$ e
$g_k$, avendo che gli ultimi due possono assumere qualsiasi valore in
$\{0,\ldots, M\}$, con $M$ numero di samples,
come con la \textit{PBWT} classica. Avendo memorizzato solo informazioni
relative alle \textit{run} bisogna quindi, ogni volta, ricondurre l'indice alla
run corretta:
\begin{itemize}
  \item nella \textit{RLPBWT na\"{i}ve} si risale all'indice di run a cui
  appartiene 
  un certo indice, in colonna $k$, in $\{0,\ldots,M\}$ scorrendo l'array $p_k$,
  come visualizzabile all'algoritmo \ref{algo:itr}, di complessità in tempo,
  con $r=|p_k|$ numero di run in colonna $k$:
  \begin{equation}
    \label{eq:itrcomp}
    \mathcal{O}(r)
  \end{equation}
  \item nella \textit{RLPBWT con bitvector} la medesima operazione viene risolta
  usando la funzione $rank_{h_k}$, avendo quindi complessità in tempo, con $r$
  numero di run in colonna $k$, ovvero il numero di simboli $\sigma=1$ in $h_k$:
  \begin{equation}
    \label{eq:itrbvcomp}
    \mathcal{O}\left(\log\frac{M}{r}\right)
  \end{equation}
\end{itemize}
\begin{algorithm}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{index\_to\_run}{$k,\,\, i$}
    \Comment $k$ indice di colonna, $i$ indice di run
    \State $run\gets 0,\,\,found\gets \bot$
    \If{$i\geq p_k[|p_k|-1]$}
    \State \textbf{return} $|p_k|-1$
    \EndIf
    \For {\textit{every} $r\in[0,|p_k|-1]$}
    \If{$p_k[r]\geq i<p_k[r+1]$}
    \State $run\gets r,\,\,found \gets \top$
    \State \textbf{break}
    \EndIf
    \EndFor
    \If {$\neg found$}
    \State $run\gets|p_k|-1$
    \EndIf
    \State \textbf{return} $run$
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per convertire un indice in indice di run}
  \label{algo:itr}
\end{algorithm}
Inoltre Durbin sfruttava il \textit{random access} al pannello, avendo in
memoria sia il pannello che il \textit{prefix array}, al fine di aggiornare il
valore di $e_k$. In entrambe le versioni già presentate della \textit{RLPBWT}
non si ha in memoria né il \textit{prefix array} né il pannello ma solo solo la
rappresentazione compatta della \textit{matrice PBWT}. Si è quindi dovuto
pensare ad un metodo che ricomponga data una riga $x_j$ del pannello $X$ a
partire da un elemento, indicizzato con $a_{k+1}[i]=j$, con $0\leq i<M$, alla
colonna $k+1$, della 
\textit{matrice PBWT}, muovendosi da destra a sinistra e seguendo in modo
inverso la permutazione che produce il \textit{prefix array}. In altri termini,
tale metodo permette un \textit{mapping inverso} che segua una riga del
pannello originale nella \textit{matrice PBWT}.\\ 
Per ottenere l'indice alla colonna $k$-esima da cui ``proviene'' la riga $j$,
indicizzata all'indice $i$ in
colonna $k+1$, si inizia analizzando il valore $c[k]$. Infatti, se $i<c[k]$,
allora sicuramente, in colonna $k$, è un indice corrispondente a $\sigma=0$
quello dal quale proviene, ricordando come la costruzione della colonna $k+1$
nella \textit{matrice PBWT} si abbia grazie ad ordinamento stabile. Si sfruttano
così o l'array $p_k$ o le funzioni 
$rank_{h_k}$ e $select_{h_k}$ per risalire all'indice in colonna $k$, calcolando
prima l'indice di run e l'eventuale offset, per il quale il mapping porta
all'indice $i'$ in colonna $k+1$, seguendo ``virtualmente'' la riga $x_j$ del
pannello originale. 
\dc{Aggiungere complessità}
Per quanto riguarda la \textit{RLPBWT na\"{i}ve} si ha lo pseudo codice per il
mapping inverso consultabile all'algoritmo \ref{algo:lfrev} mentre per quanto
riguarda la \textit{RLPBWT con bitvector} si ha l'algoritmo
\ref{algo:lfrevbv}.
\dc{Approfondire?}
\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{reverse\_map}{$k, \,\,i$}
    \Comment $k$ indice di colonna, $i$ indice di riga
    \If{$k=0$}
    \Comment by design
    \State \textbf{return} $0$
    \EndIf
    \State $k\gets k-1$
    \State $c\gets rlpbwt[k].c$
    \State $u\gets 0$, $v\gets 0$, $offset\gets 0$, $run \gets 0$,
    $found\gets \bot$
    \If {i < c}
    \State $u\gets i$
    \State $prev_0\gets 0$, $next_0\gets 0$
    \For {\textit{every} $j\in [0,|p_k|)$}
    \State $(prev_0,\_) \gets uvtrick(k,j)$
    \State $(next_0,\_) \gets uvtrick(k,j+1)$
    \If{$prev_0\leq u<next_0$}
    \State $run\gets j$,$found\gets \top$
    \State \textbf{break}
    \EndIf
    \EndFor
    \If{$\neg found$}
    \State $run \gets |p_k|-1$
    \EndIf
    \State $(curr_u,\_)\gets uvtrick(k, run)$, $offset\gets u-curr_u$
    \State \textbf{return} $p_k[run]+offset$
    \Else

    \State $v\gets i-c$
    \State $prev_1\gets 0$, $next_1\gets 0$
    \For {\textit{every} $j\in [0,|p_k|)$}
    \State $(\_,prev_1) \gets uvtrick(k,j)$
    \State $(\_,next_1) \gets uvtrick(k,j+1)$
    \If{$prev_1\leq v<next_1$}
    \State $run\gets j$,$found\gets \top$
    \State \textbf{break}
    \EndIf
    \EndFor
    \If{$\neg found$}
    \State $run \gets |p_k|-1$
    \EndIf
    \State $(curr_v,curr_u)\gets uvtrick(k, run)$, $offset\gets v-curr_v$
    \State \textbf{return} $p_k[run]+offset$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per il mapping inverso con la \textit{RLPBWT naive}.}
  \label{algo:lfrev}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{reverse\_map}{$k, \,\,i$}
    \Comment $k$ indice di colonna, $i$ indice di riga
    \If{$k=0$}
    \Comment by design
    \State \textbf{return} $0$
    \EndIf
    \State $k\gets k-1$
    \State $c\gets rlpbwt[k].c$
    \If{$i<c$}
    \If{$start^k$}
    \State $run\gets rank_u^{k}(i)\cdot 2$
    \Else
    \State $run\gets rank_u^{k}(i)\cdot 2+1$
    \EndIf
    \State $i_{run}\gets 0$
    \If{$run\neq 0$}
    \State $i_{run}\gets select_h^{k}(run)+1$
    \EndIf
    \State $(prev_0,\,\,\_)\gets uvtrick(k,\,\,i_{run})$
    \State \textbf{return} $i_{run}+(i-prev_0)$
    \Else
    \If{$start^k$}
    \State $run\gets rank_v^{k}(i)\cdot 2+1$
    \Else
    \State $run\gets rank_v^{k}(i)\cdot 2$
    \EndIf
    \State $i_{run}\gets 0$
    \If{$run\neq 0$}
    \State $i_{run}\gets select_h^{k}(run)+1$
    \EndIf
    \State $(\_,\,\,prev_1)\gets uvtrick(k,\,\,i_{run})$
    \State \textbf{return} $i_{run}+(i-(c+prev_1))$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per il inverso con la \textit{RLPBWT con bitvector}.}
  \label{algo:lfrevbv}
\end{algorithm}
Si procede quindi riadattando l'algoritmo di Durbin all'uso delle \textit{run},
ottenendo, ad ogni step, i medesimi valori per $e_k$, $f_k$ e $g_k$. Le uniche
differenze sono:
\begin{itemize}
  \item il calcolo del mapping necessità dell'estrazione dei valori $u$ e $v$,
  tenendo conto esplicito degli offset nel caso della \textit{RLPBWT na\"{i}ve}
  \item non si ha \textit{random access} al pannello quindi bisogna procedere
  ogni volta con il'inverso del mapping e il calcolo del simbolo a partire
  dall'indice della run
  \item non si ha il \textit{prefix array} in memoria quindi non è possibile
  sapere quali siano le righe che stanno matchando fino alla colonna $k$ ma solo
  quante, sapendo che sono $g_k-f_k$
\end{itemize}
Anche in questo caso i due algoritmi sono consultabili, rispettivamente,
all'algoritmo \ref{algo:matchpanel} e all'algoritmo \ref{algo:matchpanelbv}.\\
\textbf{APPROFONDIRE SPIEGAZIONE ALGORITMI}