\section{Bitvector}
\label{bvsec}
Nonostante qualche primo risultato isolato, si identifica, con la tesi di
dottorato di Jacobson 
del 1988 \cite{succinct}, l'inizio dello studio delle \textbf{strutture dati
  succinte}. Jacobson, con questo termine, denota quelle strutture dati che
usano, con $N$ numero dei differenti oggetti da memorizzare, $\log N+o(\log N)$
bit. Ad esempio, assumendo un array di $n$ bit, una struttura dati succinta
utilizza $n+o(n)$ bit, avendo infatti $N=2^n$ \cite{navarro}.\\
Un anno dopo, Jacobson \cite{jacobson} notò come una delle strutture
  dati succinte fondamentali allo sviluppo di altre strutture efficienti in
memoria fossero i cosiddetti \textbf{bitvector}.
\begin{definizione}
  Si definisce un \textbf{bitvector} $B$ come un array di lunghezza $n$,
  popolato da elementi binari. Formalmente si ha quindi:
  \begin{equation}
    \label{eq:bvdef1}
    B[i]\in\{0,1\},\,\,\forall\, i \mbox{ t.c. } 0\leq i < n
  \end{equation}
  In alternativa si potrebbe avere, come formalismo:
  \begin{equation}
    \label{eq:bvdef2}
    B[i]\in\{\bot,\top\},\,\,\forall\, i \mbox{ t.c. } 0\leq i < n
  \end{equation}
\end{definizione}
Nel corso degli ultimi anni si sono sviluppate diverse varianti dei
bitvector, finalizzate ad offrire diversi costi di complessità spaziale
e 
diversi tempi computazionali per le principali funzioni offerte.\\
Il primo vantaggio di questa struttura dati è quella di garantire \textbf{random
  access} in tempo costante, pur 
sfruttando varie tecniche per la memorizzazione efficiente della stessa in
memoria. Lo spazio necessario per l'implementazione delle principali varianti
nella \textbf{Succinct Data Structure Library (\textit{SDSL})} 
\cite{sdsl} (una delle principali librerie, scritta in \Cplusplus 11, per
strutture dati succinte) è visualizzabile in tabella 
\ref{tab:bvspace}. Il secondo vantaggio consiste nel fatto che i
bitvector permettono l'implementazione efficiente di due funzioni: la funzione
$\rank$ e la funzione $\select$.\\
Un'implementazione na\"{i}ve delle stesse richiederebbe tempo $\mathcal{O}(n)$,
dovendo scansionare l'intero \textup{bitvector}. In realtà, tali funzioni, al
costo teorico di $o(n)$ bit aggiuntivi, possono 
essere supportate in tempo costante. Si noti però che, nelle implementazioni
della SDSL, le complessità temporali delle due funzioni possono variare, sia
in termini di bit aggiuntivi che di complessità temporale, a seconda della
tipologia di bitvector.
\dc{Mi è sembrato utile riportare tali tabelle}
% tabella dello spazio occupato dalle varianti dei bitvector
\begin{table}[H]
  \small
  \centering
  \caption{Stime dello spazio occupato (bit) per la memorizzazione di alcune varianti
    di \textit{bitvector}. Si 
    assume un bitvector di lunghezza $n$ con un numero di simboli $\sigma=1$
    (o $\sigma=\top$) pari a $m$. $K$ indica la \textit{block size} per
    l'\textit{interleave}.}  
  \begin{tabular}{c|c}
    \textbf{Variante} & \textbf{Spazio occupato}\\
    \hline\xrowht{15pt}
    \textit{Plain bitvector} & $64\big\lceil\frac{n}{64}+1\big\rceil$\\
    \hline\xrowht{15pt}
    \textit{Interleaved bitvector} & $\approx n\left(1+\frac{64}{K}\right)$\\
    \hline\xrowht{15pt}
    \textit{$H_0$-compressed bitvector} & $\approx\big\lceil\log\binom{n}{m}\big\rceil$\\
    \hline\xrowht{15pt}
    \textit{Sparse bitvector} & $\approx m\left(2+\log\frac{n}{m}\right)$\\
  \end{tabular}
  \label{tab:bvspace}
\end{table}

\subsection{Funzione rank}
La prima funzione che si approfondisce è la funzione $\rank$.
Tale funzione permette di calcolare il \textit{rango} di un dato elemento del
bitvector.
\begin{definizione}
  Dato un bitvector $B$, lungo $n$, e data una certa posizione $i$ del
  \textit{bitvector}, la  funzione $\rank$ restituisce il numero di valori
  uguali a 1
  presenti fino a quella data posizione, esclusa. Più formalmente si ha che:
  \begin{equation}
    \label{eq:rankbv}
    \rank_B(i)=\sum_{k=0}^{k<i}B[k],\,\,\forall\, i \mbox{ t.c. } 0\leq i < n
\end{equation}
\end{definizione}
Come detto, da un punto di vista teorico, al costo di $o(n)$ bit
aggiuntivi in memoria tale funzione sarebbe supportata in tempo
$\mathcal{O}(1)$. La complessità temporale varia però a seconda
dell'implementazione, anche in conseguenza al fatto che si ha una quantità
diversa di bit aggiuntivi salvati in memoria.
La tabella con le complessità temporali stimate della funzione $\rank$,
per le varianti di bitvector implementate nella SDSL, è
visualizzabile in tabella \ref{tab:rank}.
% tabella relativa ai costi della funzione rank dei bitvector
\begin{table}[H]
  \small
  \centering
  \caption{Complessità temporali stimate della funzione $\rank$ per alcune
    varianti di bitvector, con la quantità di bit aggiuntivi
    richiesta. Si assume un 
    bitvector di lunghezza $n$, con un numero di simboli $\sigma=1$
    (o $\sigma=\top$) pari a $m$, e un numero $k$ di \textit{rank
      sample}.}  
  \begin{tabular}{c|c|c}
    \textbf{Variante} & \textbf{Bit aggiuntivi} & \textbf{Complessità
                                                  temporale}\\ 
    \hline\xrowht{15pt}
    \textit{Plain bitvector} & $0.0625\cdot n$ & $\mathcal{O}(1)$\\
    \hline\xrowht{15pt}
    \textit{Interleaved bitvector} & $128$ & $\mathcal{O}(1)$\\
    \hline\xrowht{15pt}
    \textit{$H_0$-compressed bitvector} & $80$ & $\mathcal{O}(k)$\\
    \hline\xrowht{15pt}
    \textit{Sparse bitvector} & $64$
                              & $\mathcal{O}\left(\log\frac{n}{m}\right)$\\  
  \end{tabular}
  \label{tab:rank}
\end{table}
\subsection{Funzione select}
La seconda funzione fondamentale è la funzione $\select$, la quale
permettere di ottenere l'indice di un simbolo $\sigma=1$ nel bitvector.
\begin{definizione}
  Dato un bitvector $B$, lungo $n$, e dato un valore intero $i$, la
  funzione $\select$ calcola l'indice dell'$i$-esimo valore
  pari a 1 nel bitvector $B$. Più formalmente si ha che:
  \begin{equation}
    \label{eq:selectbv}
    \select_B(i)=\min\{j < n\,|\,\,rank_B(j+1)=1\},\,\,\forall\, i \mbox{ t.c. }
    0<i\leq rank_B(n)
  \end{equation}
\end{definizione}
Anche in questo caso vale lo stesso discorso fatto per la funzione $\rank$
in merito alla complessità temporale e ai bit aggiuntivi. La tabella con le
complessità temporali stimate della funzione $\select$, 
per le varianti di bitvector implementate nella SDSL, è
visualizzabile in tabella \ref{tab:select}.\\
% tabella relativa ai costi della funzione select dei bitvector
\begin{table}[H]
  \small
  \centering
  \caption{Complessità temporali stimate della funzione $\select$ per
    alcune varianti di bitvector, con la quantità di bit aggiuntivi
    richiesta. Si assume un bitvector di lunghezza $n$.} 
  \begin{tabular}{c|c|c}
    \textbf{Variante} & \textbf{Bit aggiuntivi} & \textbf{Complessità
                                                  temporale}\\ 
    \hline\xrowht{15pt}
    \textit{Plain bitvector} & $\leq 0.2\cdot n$ & $\mathcal{O}(1)$\\
    \hline\xrowht{15pt}
    \textit{Interleaved bitvector} & $64$ & $\mathcal{O}(\log n)$\\
    \hline\xrowht{15pt}
    \textit{$H_0$-compressed bitvector} & $64$ & $\mathcal{O}(\log n)$\\
    \hline\xrowht{15pt}
    \textit{Sparse bitvector} & $64$ & $\mathcal{O}(1)$\\ 
  \end{tabular}
  \label{tab:select}
\end{table}
\begin{esempio}
  Ipotizziamo di avere il seguente bitvector $B$, di lunghezza $n=14$:
  \begin{center}
    \begin{tikzpicture} [nodes in empty cells,
      nodes={minimum width=0.6cm, minimum height=0.6cm},
      row sep=-\pgflinewidth, column sep=-\pgflinewidth]
      border/.style={draw}
      
      \matrix(vector)[matrix of nodes,
      row 1/.style={nodes={draw=none, minimum width=0.3cm}},
      nodes={draw}]
      {
        \tiny{0} & \tiny{1} & \tiny{2} & \tiny{3} & \tiny{4} & \tiny{5}&\tiny{6}
        & \tiny{7} & \tiny{8} & \tiny{9} & \tiny{10} & \tiny{11} & \tiny{12} &
        \tiny{13}\\  
        $\mathbf{1}$ & $0$ & $0$ & $\mathbf{1}$ & $0$ & $\mathbf{1}$ & $0$ &
        $\mathbf{1}$ & $0$ & $\mathbf{1}$ & $0$ & $0$ & $\mathbf{1}$ & $0$\\ 
      };
    \end{tikzpicture}
  \end{center}
  Si ha che, per esempio:
  \[\rank(6)=3\]
  \[\select(5) =9\]
\end{esempio}
Si vedrà, in questo progetto di tesi, come l'uso di
tali strutture, nelle varianti \textit{plain bitvector} e
\textit{bitvector sparsi}, sia fondamentale per lo studio delle due strutture
run-length encoded.


