\section{Suffix Array}
Nel 1976, Manber e Myers \cite{sa} proposero una struttura dati per la
memorizzazione di 
stringhe e la loro interrogazione, efficiente sia in termini di uso della
memoria che di complessità temporale. Tale struttura venne denotata
\textbf{Suffix Array (\textit{SA})}.
\begin{definizione}
  Dato un testo $T$, \$-terminato (assumendo che il simbolo \$ sia sempre il
  simbolo lessicograficamente minore nell'alfabeto di studio), tale che $|T|=n$,
  si definisce \textbf{suffix 
    array} di $T$, denotato con $SA_T$, un di interi array lungo $n$, tale che
  $SA_T[i]=j$ sse il suffisso di ordine $j$, ovvero $T[j,n-1]$, è
  l'$i$-esimo suffisso nell’ordinamento lessicografico dei suffissi di $T$. Ne
  segue che, presi $i,i'\in \mathbb{N}$
  tali che $0\leq i < i' < n$ allora vale che, indicando con $\prec$
  l'ordinamento lessicografico:
  \begin{equation}
    \label{eq:saord}
    T[SA_T[i],n-1] \prec T[SA_T[i'],n-1]
  \end{equation}
  Il \textbf{suffix array} è quindi una permutazione dei numeri interi in
  $\{0,n-1\}$. 
\end{definizione}
\begin{esempio}
  Si prenda la stringa:
  \[s=\mbox{mississippi\$},\,\,|s|=12\]
  Si producono quindi i seguenti suffissi e il loro riordinamento:
  \begin{table}[H]
    \footnotesize
    \centering
    \begin{tabular}{c|l}
      \textbf{Indice del suffisso} & \textbf{Suffisso}\\
      \hline
      0 & mississippi\$\\
      1 & ississippi\$\\
      2 & ssissippi\$\\
      3 & sissippi\$\\
      4 & issippi\$\\
      5 & ssippi\$\\
      6 & sippi\$\\
      7 & ippi\$\\
      8 & ppi\$\\
      9 & pi\$\\
      10 & i\$\\
      11 & \$\\
    \end{tabular}
    \quad $\implies$\quad
    \begin{tabular}{c|l} 
      \textbf{Indice del suffisso} & \textbf{Suffisso}\\ 
      \hline
      11 & \$\\
      10 & i\$\\
      7 & ippi\$\\
      4 & issippi\$\\
      1 & ississippi\$\\
      0 & mississippi\$\\
      9 & pi\$\\
      8 & ppi\$\\
      6 & sippi\$\\
      3 & sissippi\$\\
      5 & ssippi\$\\
      2 & ssissippi\$\\
    \end{tabular}
  \end{table}
  Ottenendo quindi che:
  \[SA_T=[11,10,7,4,1,0,9,8,6,3,5,2]\]
\end{esempio}
\subsection{Longest common prefix}
L'uso del \textit{suffix array} è spesso accompagnato da un'altra struttura
dati, detta \textbf{Longest Common Prefix}.
\begin{definizione}
  Si definisce il \textbf{Longest Common Prefix (\emph{LCP})} di un testo $T$
  lungo $n$,
  denotato con $LCP_T$, come un array lungo $n+1$, contenente la
  lunghezza del prefisso comune tra ogni coppia di suffissi consecutivi
  nell'ordinamento lessicografico dei suffissi, ovvero l'ordinamento specificato
  da $SA_T$. Più formalmente
  $LCP_T$ è un array tale che, avendo $0\leq i\leq n$ e indicando con $lcp(x,y)$
  il più lungo prefisso comune tra le stringhe $x$ e $y$:
  \begin{equation}
    \label{eq:lcpdef}
    LCP_T[i]=
    \begin{cases}
      -1&\mbox{ se } i=0 \lor i=n\\
      \left|lcp(T[SA_T[i-1], n],T[SA_T [i], n])\right|&\mbox{ altrimenti}
    \end{cases}
  \end{equation}
\end{definizione}
\begin{esempio}
  Riprendendo l'esempio precedente si avrebbe quindi:
  \begin{table}[H]
    \centering
    \footnotesize
    \begin{tabular}{c|c|c|l} 
      \textbf{Indice} & $\mathbf{SA_T}$ & $\mathbf{LCP_T}$ & \textbf{Suffisso}\\ 
      \hline
      0 & 11 & -1 & \$\\
      1 & 10 & 0 & i\$\\
      2 & 7 & 1 & \underline{i}ppi\$\\
      3 & 4 & 1 & \underline{i}ssippi\$\\
      4 & 1 & 4 & \underline{issi}ssippi\$\\
      5 & 0 & 0 & mississippi\$\\
      6 & 9 & 0 & pi\$\\
      7 & 8 & 1 & \underline{p}pi\$\\
      8 & 6 & 0 & sippi\$\\
      9 & 3 & 2 & \underline{si}ssippi\$\\
      10 & 5 & 1 & \underline{s}sippi\$\\
      11 & 2 & 3 & \underline{ssi}ssippi\$\\
      12 & - & -1 & -
    \end{tabular}
  \end{table}
\end{esempio}
Senza entrare in ulteriori dettagli relativi all'algoritmo di pattern matching
tramite \textit{SA} e \textit{LCP}, in quanto non centrali per il resto della
trattazione, risulta comunque interessante riportare le complessità
temporali. Si ha quindi che, per l'algoritmo di query su \textit{SA} senza l'uso
dell'\textit{LCP}, si ha, per un testo lungo $n$ e un pattern lungo $m$:
\begin{equation}
  \label{eq:satime}
  \mathcal{O}(m\log n)
\end{equation}
Con l'uso dell'\textit{LCP} questo si riduce a:
\begin{equation}
  \label{eq:salcptime}
  \mathcal{O}(m+\log n)
\end{equation}
Per ulteriori approfondimenti in merito agli algoritmi di pattern matching
basati su \textit{suffix array} e ai relativi \textit{acceleratori}, si rimanda
al testo di Gusfield \cite{gusfield1997}.
\subsection{SA inverso}
Ai fini di poter comprendere future definizioni si presenta anche la
permutazione inversa dei valori del \textit{suffix array}, detta
\textbf{Inverse Suffix Array (\textit{ISA})}. Grazie a tale permutazione
inversa, dato un indice di suffisso, è possibile sapere in quale posizione si
trovi tale suffisso nel \textit{suffix array}.  
\begin{definizione}
  Dato il \textbf{suffix array} $SA_T$, costruito su un testo $T$ di lunghezza
  $n$, si definisce l'\textbf{inverse suffix array}, denotato con $ISA_T$, come:
  \begin{equation}
    \label{eq:isadef}
    ISA_T[i]=j\iff SA_T[j]=i,\,\,\forall\, i\in\{0,n-1\}
  \end{equation}
\end{definizione}

\begin{esempio}
  Riprendendo l'esempio precedente si avrebbe quindi:
  \begin{table}[H]
    \centering
    \footnotesize
    \begin{tabular}{c|c|c|l} 
      \textbf{Indice} & $\mathbf{SA_T}$ & $\mathbf{ISA_T}$ & \textbf{Suffisso}\\ 
      \hline
      0 & 11 & 5 & \$\\
      1 & 10 & 4 & i\$\\
      2 & 7 & 11 & ippi\$\\
      3 & 4 & 9 & issippi\$\\
      4 & 1 & 3 & ississippi\$\\
      5 & 0 & 10 & mississippi\$\\
      6 & 9 & 8 & pi\$\\
      7 & 8 & 2 & ppi\$\\
      8 & 6 & 7 & sippi\$\\
      9 & 3 & 6 & sissippi\$\\
      10 & 5 & 1 & ssippi\$\\
      11 & 2 & 0 & ssissippi\$\\
    \end{tabular}
  \end{table}
\end{esempio}
\subsection{LCP permutato}
Un'altra permutazione che bisogna introdurre è il \textbf{permuted
  longest-common-prefix array (\textit{PLCP})} \cite{plcp}.
Tale permutazione
permette una rappresentazione succinta in memoria dell'\textit{LCP}
\cite{plcp2},
permettendo di ottenere gli stessi risultati di quest'ultimo. Un'altro vantaggio
è che la sua ricostruzione richiede un minor costo computazionale.
\dc{L'intera sottosezione potrebbe essere quasi totalmente rimossa ma almeno al
  definizione serve per il calcolo di tutte le occorrenze di un MEM, come in
  PHONI} 
\begin{definizione}
  Si definisce il \textbf{permuted longest-common-prefix array}, denotato con
  $PLCP_T$, costruito a partire da un testo $T$ di lunghezza $n$, come un
  array tale per cui \cite{phoni}:
  \begin{equation}
    \label{eq:plcpdef1}
    PLCP_T[p]=
    \begin{cases}
      -1&\mbox{se }ISA_T[p]=0\\
      LCP_T[ISA_T[p]]&\mbox{altrimenti}
    \end{cases},\,\,\forall\, p\in\{0,n-1\}
  \end{equation}
  Quindi, i valori sono in ordine di posizione, ovvero l'ordine originale dato
  dagli indici dei suffissi, e non
  lessicografico. In altri termini, si ha una permutazione dei valori di $LCP_T$
  tale per cui \cite{plcp}:
  \begin{equation}
    \label{eq:plcpdef2}
    PLCP_T[SA_T[p]] = LCP_T[p],\,\,\,\forall\, p\in\{1,n-1\}
  \end{equation}
\end{definizione}
\begin{esempio}
  Riprendendo l'esempio precedente si avrebbe quindi:
  \begin{table}[H]
    \centering
    \footnotesize
    \begin{tabular}{c|c|c|c|c|l} 
      \textbf{Indice} & $\mathbf{SA_T}$ & $\mathbf{ISA_T}$ & $\mathbf{LCP_T}$
      & $\mathbf{PLCP_T}$ & \textbf{Suffisso}\\  
      \hline
      0 & 11 & 5 & -1 & 0 & \$\\
      1 & 10 & 4 & 0 & 4 & i\$\\
      2 & 7 & 11 & 1 & 3 & \underline{i}ppi\$\\
      3 & 4 & 9 & 1 & 2 & \underline{i}ssippi\$\\
      4 & 1 & 3 & 4 & 1 & \underline{issi}ssippi\$\\
      5 & 0 & 10 & 0 & 1 & mississippi\$\\
      6 & 9 & 8 & 0 & 0 & pi\$\\
      7 & 8 & 2 & 1 & 1 & \underline{p}pi\$\\
      8 & 6 & 7 & 0 & 1 & sippi\$\\
      9 & 3 & 6 & 2 & 0 & \underline{si}ssippi\$\\
      10 & 5 & 1 & 1 & 0 & \underline{s}sippi\$\\
      11 & 2 & 0 & 3 & -1 & \underline{ssi}ssippi\$\\
      12 & - & - & -1 & - & - 
    \end{tabular}
  \end{table}
\end{esempio}
Ciò che permette una rappresentazione compatta del \textit{PLCP} è descritto nel
seguente lemma \cite{plcp3}.
\begin{lemma}
  Dato un testo $T$, tale che $|T|=n$, si ha che:
  \begin{equation}
    \label{eq:plcpdef3}
    PCLP_T[i]\geq PLCP_T[i-1]-1,\,\,\forall\, i\in\{1,n-1\}
  \end{equation}
\end{lemma}
Grazie a tale lemma si può memorizzare l'\textit{PLCP sparso}.
\begin{definizione}
  Dato un intero
  $q$, per il quale calcolo (basato sul lemma precedente) si rimanda al paper di
  Kasai \cite{plcp3}, si definisce \textbf{array PCLP sparso}, lungo
  $\left\lfloor\frac{n}{q}\right\rfloor$ e denotato $PLCP_q$, l'array che
  memorizza ogni $q$-esimo valore del \textit{PLCP}, avendo che:
  \begin{equation}
    \label{eq:plcpdef4}
    PLCP_q[i]=PLCP_T[iq]
  \end{equation}
\end{definizione}
\dc{Capire se serve variante sparsa e se serve esempio}
\subsection{Funzione phi}
L'ultimo concetto che si introduce sono le \textbf{funzioni}
$\boldsymbol\varphi$ e $\mathbf{\boldsymbol\varphi^{-1}}$, usate per poter
identificare i valori precedenti e successivi di 
un dato valore in $SA_T$. Essere sono utili al fine di poter sia ricostruire
efficientemente il \textit{PLCP} di un testo $T$ (per i dettagli si rimanda
all'articolo di K\"{a}rkk\"{a}inen \cite{plcp}) che di permettere, come si vedrà
più  avanti nella sezione \ref{secbwt}, il riconoscimento di tutte le occorrenze
di un \textbf{match massimale esatto (\textit{MEM})} in $T$ \cite{phoni}.
\begin{definizione}
  Dato un testo $T$ di lunghezza $n$ si definiscono le funzioni, che di fatto
  sono permutazioni dei valori di $SA_T$, $\boldsymbol\varphi$ e
  $\mathbf{\boldsymbol\varphi^{-1}}$ come \cite{phoni}: 
  \begin{equation}
    \label{eq:phidef1}
    \varphi(p)=
    \begin{cases}
      null&\mbox{se } ISA_T[p]=0\\
      SA_T[ISA_T[p]-1]&\mbox{altrimenti}
    \end{cases},\,\,\forall\, p\in\{0,n-1\}
  \end{equation}
  \begin{equation}
    \label{eq:phiinvdef1}
    \varphi(p)^{-1}=
    \begin{cases}
      null&\mbox{se } ISA_T[p]=n-1\\
      SA_T[ISA_T[p]+1]&\mbox{altrimenti}
    \end{cases},\,\,\forall\, p\in\{0,n-1\}
  \end{equation}
  Si noti che si ha il valore $null$ quando, rispettivamente, si studia il
  primo e l'ultimo valore del \textit{suffix array} in quanto non hanno, sempre
  rispettivamente, l'antecedente e il successore.   Infatti, semplicemente, tali
  funzioni restituiscono i due valori, se 
  esistenti, di $SA_T$ adiacenti ad un valore del suffix array dato.\\
  Analogamente, sempre coi medesimi vincoli, possono essere definite come
  \cite{plcp}: 
  \begin{equation}
    \label{eq:phidef2}
    \varphi[SA[p]]=SA[p-1]
  \end{equation}
  \begin{equation}
    \label{eq:phiinvdef2}
    \varphi^{-1}[SA[p]]=SA[p+1]
  \end{equation}

\end{definizione}
\begin{esempio}
   Riprendendo l'esempio precedente si avrebbe quindi:
   % \begin{table}[H]
   %   \centering
   %   \footnotesize
   %   \begin{tabular}{c|c|c|c|c|c|c|l} 
   %     \textbf{Indice} & $\mathbf{SA_T}$ & $\mathbf{ISA_T}$ & $\mathbf{LCP_T}$
   %     & $\mathbf{PLCP_T}$ & $\mathbf{\boldsymbol\varphi}$
   %     & $\mathbf{\boldsymbol\varphi^{-1}}$ & \textbf{Suffisso}\\  
   %     \hline
   %     0 & 11 & 5 & -1 & 0 & 1 & 9 & \$\\
   %     1 & 10 & 4 & 0 & 4 & 4 & 0 & i\$\\
   %     2 & 7 & 11 & 1 & 3 & 5 & $null$ & ippi\$\\
   %     3 & 4 & 9 & 1 & 2 & 6 & 5 & issippi\$\\
   %     4 & 1 & 3 & 4 & 1 & 7 & 1 & ississippi\$\\
   %     5 & 0 & 10 & 0 & 1 & 3 & 2 & mississippi\$\\
   %     6 & 9 & 8 & 0 & 0 & 8 & 3 & pi\$\\
   %     7 & 8 & 2 & 1 & 1 & 10 & 4 & ppi\$\\
   %     8 & 6 & 7 & 0 & 1 & 9 & 6 & sippi\$\\
   %     9 & 3 & 6 & 2 & 0 & 0 & 8 & sissippi\$\\
   %     10 & 5 & 1 & 1 & 0 & 11 & 7 & ssippi\$\\
   %     11 & 2 & 0 & 3 & 0/-1 & $null$ & 10 & ssissippi\$\\
   %   \end{tabular}
   % \end{table}
   \begin{table}[H]
     \centering
     \footnotesize
     \begin{tabular}{c|c|c|c|c|l} 
       \textbf{Indice} & $\mathbf{SA_T}$ & $\mathbf{ISA_T}$
       & $\mathbf{\boldsymbol\varphi}$
       & $\mathbf{\boldsymbol\varphi^{-1}}$ & \textbf{Suffisso}\\  
       \hline
       0 & 11 & 5 & 1 & 9 & \$\\
       1 & 10 & 4 & 4 & 0 & i\$\\
       2 & 7 & 11 & 5 & $null$ & ippi\$\\
       3 & 4 & 9 & 6 & 5 & issippi\$\\
       4 & 1 & 3 & 7 & 1 & ississippi\$\\
       5 & 0 & 10 & 3 & 2 & mississippi\$\\
       6 & 9 & 8 & 8 & 3 & pi\$\\
       7 & 8 & 2 & 10 & 4 & ppi\$\\
       8 & 6 & 7 & 9 & 6 & sippi\$\\
       9 & 3 & 6 & 0 & 8 & sissippi\$\\
       10 & 5 & 1 & 11 & 7 & ssippi\$\\
       11 & 2 & 0 & $null$ & 10 & ssissippi\$\\
     \end{tabular}
   \end{table}
  Infatti, ad esempio, il valore $9$ in $SA_T$ è preceduto dal valore
  $\varphi(9)=0$ ed è seguito dal valore $\varphi^{-1}(9)=8$.
\end{esempio}
