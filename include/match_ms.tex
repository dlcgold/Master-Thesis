\subsection{Calcolo degli SMEM con matching statistics}
L'obiettivo principale di questa tesi è quello di applicare i metodi e gli
algoritmi già 
studiati per la $\RLBWT$ alla $\RLPBWT$.\\
Nelle sei strutture dati dedicate al calcolo degli $\SMEM$ tramite matching
statistics, si riconoscono le due modalità già descritte con MONI \cite{moni} e
PHONI \cite{phoni}:
\begin{enumerate}
  \item calcolare l'array $\MS$, in due passaggi, sfruttando le threshold per
  computare i valori $\MS[i].\row$ e il
  random access al pannello per calcolare i valori $\MS[i].\len$
  \item calcolare l'array $\MS$, in un passaggio, sfruttando le $\LCE$ query
  sia per scegliere le righe da memorizzare in $\MS[i].\row$ che per calcolare,
  in contemporanea, i valori $\MS[i].\len$ 
\end{enumerate}
Grazie a queste due strategie, si possono computare tutti gli $\SMEM$ senza
tenere in memoria il divergence array.
\subsubsection{Calcolo dell'array delle matching statistics tramite threshold}
Questa prima soluzione, necessitando sia della componente
\texttt{THR-INT}/\texttt{THR-BV} che della componente
\texttt{RA-BV}/\texttt{RA-SLP}, è relativa alle seguenti strutture dati
composte: 
\begin{itemize}
  \item \texttt{MAP-INT + THR-INT + RA-BV + PERM + PHI}
  \item \texttt{MAP-INT + THR-INT + RA-SLP + PERM + PHI}
  \item \texttt{MAP-BV + THR-BV + RA-BV + PERM + PHI}
  \item \texttt{MAP-BV + THR-BV + RA-SLP + PERM + PHI}
\end{itemize}
Tra queste soluzioni, le uniche differenze si riscontrano nei tempi d'esecuzione
e nella memoria richiesta.\\
% Si noti che unendo la componente \texttt{PERM} alla componente
% \texttt{THR-INT}/\texttt{THR-BV} si ottiene una variante dell'\textbf{R-index}
% visto per la \textit{RLBWT}.\\
Si supponga di aver computato l'array delle matching statistics fino alla
colonna $k-1$ e di processare la colonna corrente $k$.
Sia $i$ la riga della matrice $\PBWT$ che ha un match con il più lungo
suffisso di $z[0,k-1]$ che è suffisso di almeno uno tra $x_0[0,k-1]$, $\ldots$,
$x_{M-1}[0,k-1]$. Sia $p$ la corrispondente riga, sul pannello in input $X$,
della riga
$i$ sulla matrice $\PBWT$. Tale valore è ottenibile tramite il prefix array,
avendo $p=a_k[i]$. Si ha, 
denotando con
$\lcs(A,B)$ il più lungo suffisso comune tra le stringhe $A$ e $B$, che:
\begin{equation}
  \label{eq:thr1}
  |\lcs(z[0,k-1], x_{p}[0,k-1])|\geq |\lcs(z[0,k-1],
  x_{a_k[j]}[0,k-1])|,\,\,\forall\, 
  j\in[0,M-1] 
\end{equation}
Qualora si abbia $y_i^k[k]=z[k]$, ovvero un match tra il
$k$-esimo carattere della query e il carattere in riga $i$ della matrice
$\PBWT$, si 
avrebbe che $\MS[k].\row=a_k[i]=p$ e $\MS[k].\len =
\MS[k-1].\len+1$, in 
quanto si seguirebbe la medesima riga dello step precedente del calcolo
delle matching statistics.\\
In caso contrario, si avrebbe 
$y_i^k[k]\neq z[k]$, ovvero un mismatch tra il $k$-esimo carattere
della query è il carattere in riga $i$ della matrice $\PBWT$. Bisogna,
quindi, scegliere un nuovo indice $i'$ nella matrice $\PBWT$,
corrispondente all'indice $p'$ nella pannello in input, che, a sua volta,
corrisponde alla riga 
con il suffisso più lungo possibile comune con la query, che sia estendibile
anche in 
colonna $k$. Sia $y_{[s,e]}^k[k]$ l'intervallo corrispondente alla run che
contiene l'indice $i$, nella matrice $\PBWT$. Il più lungo suffisso
di $z[0,k]$, che è suffisso di almeno uno tra $x_0[0,k]$, $\ldots$,
$x_{M-1}[0,k]$, corrisponde alla fine della run precedente di simboli
$\sigma=z[k]$ o all'inizio della run successiva di simboli
$\sigma=z[k]$, nella colonna $k$. Formalmente,
tale suffisso corrisponde a uno tra $X_{a_k[s-1]}[0,k]$, se $s>0$, e
$X_{a_k[e+1]}[0,k]$, se 
$e<M-1$. L'uso delle threshold permette di capire quale tra le righe $a_k[s-1]$
e $a_k[e+1]$ del pannello in input, se esistenti, abbia il più lungo suffisso
comune con $z[0,k]$. \\
Sia $t$ l'indice della threshold nella run corrente. Si hanno due casi
possibili:
\begin{enumerate}
  \item $i<t$, allora, per la definizione di threshold:
  \begin{equation}
    \label{eq:thrra2}
    |\lcs(z[0,k], x_{a_{k}[s-1]}[0,k])|\geq |\lcs(z[0,k], x_{a_{k}[e+1]}[0,k])|
  \end{equation}
  Quindi si ha che $\MS[k].\row=a_{k}[s-1]=p$ e il mapping potrà proseguire
  dall'indice $s-1$
  \item  $i\geq t$ allora, per definizione di threshold:
  \begin{equation}
    \label{eq:thrra1}
    |\lcs(z[0,k], x_{a_{k}[s-1]}[0,k])|\leq |\lcs(z[0,k], x_{a_{k}[e+1]}[0,k])|
  \end{equation}
  Quindi si ha che $\MS[k].\row=a_{k}[e+1]$ e il mapping potrà proseguire
  dall'indice $e+1$
\end{enumerate}
Si ricorda il caso in cui la threshold sia posta a fine run, nel caso
della componente \texttt{THR-BV}. In tale situazione, bisognerebbe scegliere la
testa della run successiva, qualora l'indice $i$ 
si trovi esattamente a fine run. Invece, bisognerebbe scegliere la coda della
run precedente qualora la
threshold sia a fine run, a causa del fatto che il minimo $\RLCP$
si trovi nella testa della run successiva.
L'unico modo per disambiguare è effettuare random
access al pannello o calcolare una $\LCE$ query, per vedere quale, tra la coda
della run precedente e la testa
della run successiva, sia relativa alla riga del pannello originale con un
suffisso comune alla query più lungo.\\
Una volta computati tutti i valori $\MS[i].\row$, per calcolare i valori
$\MS[i].\len$,
si scorre da sinistra a destra calcolando la lunghezza del match fino alla
colonna $i$, facendo random
access al pannello e confrontando la query $z$ con la riga $\MS[i].\row$. Si
assuma di aver calcolato $\MS[i-1].\len$ e di voler calcolare
$\MS[i].\len$. 
Si hanno tre casi possibili:
\begin{enumerate}
  \item $\MS[i].\row=M$. In tal caso, avendo segnalata l'inesistenza di un
  match terminante in colonna $i$, si ha che $\MS[i].\len=0$
  \item $\MS[i].\row=\MS[i-1].\row$, avendo $i\neq 0$ e $\MS[i-1].\len\neq 0$.
  In tal caso,
  si sta seguendo la medesima riga ottenuta in colonna $i-1$ e quindi
  $\MS[i].\len=\MS[i-1].\len+1$, dovendo conteggiare il carattere
  della colonna corrente
  \item in qualsiasi altro caso bisogna confrontare, a partire dalla colonna
  $i$, la query 
  $z$ con la riga $\MS[i].\row$ del pannello, da destra a sinistra, fino a che
  non si trova un mismatch, calcolando la lunghezza $l$ del suffisso comune tra
  esse e memorizzando tale valore come $\MS[i].\len=l$
\end{enumerate}
In fase di costruzione delle lunghezze, è possibile anche riportare gli
$\SMEM$, terminanti in colonna $i$, qualora:
\begin{itemize}
  \item $\MS[i].\len\geq \MS[i+1].\len \land \MS[i].\len\neq 0$
  \item si è arrivati a fine query, avendo $i=N-1\land \MS[i].\len\neq 0$
\end{itemize}
Queste condizioni segnalano che non è possibile estendere a destra il più lungo
suffisso comune, terminante in colonna $i$, tra la query e una qualsiasi riga del
pannello di input. 
Questo si può verificare anche nell'esempio \ref{es:ms}.
\begin{esempio}
  \label{es:thr}
  Si vede un esempio di funzionamento delle threshold per la scelta
  della riga da memorizzare in $\MS[i].\row$ dopo un mismatch.\\
  Si prende il pannello visto all'esempio \ref{es:pbwt1} e si effettua la
  permutazione secondo $a_2$:
  \begin{table}[H]
    \centering
    \footnotesize
    \begin{tabular}{c|cc|c|cccccccccccc}
      X & 00 & 01 & 02 & 03 & 04 & 05 & 06 & 07 & 08 & 09 & 10 & 11 & 12 & 13
      & 14 \\
      \hline
      00 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 \\
      01 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
      02 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      03 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      04 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      05 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      06 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      07 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
      08 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 1 \\
      09 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
      10 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
      11 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
      12 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 \\
      13 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 \\
      14 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
      15 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
      16 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 \\
      17 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\
      18 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
      19 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 \\
    \end{tabular}
  \end{table}
  \noindent
  Si prende la seconda run, di simboli $\sigma=1$, indicizzata tra 17 e 18. \\
  Si suppone che, tramite il mapping, si sia arrivati alla riga 17 ma che si
  abbia $z[2]=0$. La scelta è, quindi, tra la coda della run precedente, avendo
  che $a_2[16]=16$ o la testa della run successiva, avendo che $a_2[19]=17$. Si
  può notare come il minimo $\RLCP$ si trovi, per la 
  run, all'indice 18 (a causa del fatto che il minimo $\RLCP$ è all'indice
  19, quello della testa della run successiva). L'indice in cui ci si trova, il
  17, è quindi sopra la threshold.
  Questo significa che il suffisso comune più lungo
  con la query si ha 
  con la riga 16 del pannello, per la definizione di threshold, avendo che
  questa sarà memorizzata nell'array $\MS$ ($\MS[2].\row=16$).\\
  Successivamente,  sfruttando $\MS[1].\len$ o tramite random access al testo,
  confrontando la riga 
  $x_{16}$ e la query $z$ fino alla colonna $k=2$, si può calcolare che
  $\MS[2].\len=3$. 
\end{esempio}
L'algoritmo per il il calcolo degli $\SMEM$ tramite threshold è visualizzabile
all'algoritmo \ref{algo:matchthr}. All'algoritmo \ref{algo:updatems}
si riporta il metodo di $\UP$ delle informazioni, nel passaggio dalla
colonna 
$k$ alla colonna $k+1$, di complessità pari a quella per effettuare il
mapping. Si noti che è 
possibile usare la funzione $\W$, 
spiegata in precedenza, in quanto, avendo per costruzione
$y^k_{curr\_index}[k]=z[k]$, si ha
che la funzione segue esattamente una certa riga da una colonna alla
successiva nella matrice $\PBWT$. \\
Anche in questo caso, la stima delle
complessità non è di facile ottenimento. Dividendo nelle varie parti
l'algoritmo, si ha che:
\begin{itemize}
  \item il calcolo dei valori $MS[i].\row$ varia a
  seconda dell'uso 
  della componente \texttt{MAP-INT} o \texttt{MAP-BV}. Il costo della funzione
  \texttt{down}, che risolve l'eventuale ambiguità della threshold a fine run,
  è variabile a seconda della componente usata per il random access (e 
  dell'eventuale componente \texttt{LCE}) e risulta trascurabile vista la bassa
  frequenza d'uso, in termini probabilistici. Si ha, quindi, che, con $\rho$
  numero medio di run per colonna, usando \texttt{MAP-INT}, il tempo è
  proporzionale a:
  \begin{equation}
    \label{eq:msthr1int}
    \mathcal{O}(N\log\rho)
  \end{equation}
  Mentre, usando la componente \texttt{MAP-BV}, è proporzionale a:
  \begin{equation}
    \label{eq:msthr1bv}
    \mathcal{O}\left(N\log\frac{M}{\rho}\right)
  \end{equation}
  \item il calcolo dei valori $\MS[i].\len$ (e degli $\SMEM$ direttamente
  calcolabili da essi) è il
  più complesso da 
  stimare, in termini di complessità asintotica. Questa difficoltà è dovuta dal
  fatto che gli accessi al pannello vengono fatti solo quando $\MS.\row[i]\neq
  \MS.\row[i-1]$.
  Ipotizzando un caso peggiore dove si ha necessità di accedere al pannello in
  ogni 
  colonna, nel caso della componente \texttt{RA-BV}, il calcolo
  complessivo delle lunghezza è proporzionale a:
  \begin{equation}
    \label{eq:msthr2bv}
    \mathcal{O}(N^2)
  \end{equation}
  Mentre, con l'uso della componente \texttt{RA-SLP}, la complessità in tempo
  è proporzionale a: 
  \begin{equation}
    \label{eq:msthr2slp}
    \mathcal{O}\left(N^2\log (NM)\right)
  \end{equation}
  In aggiunta bisogna considerare i costi della componente \texttt{PHI} per il
  computo di tutti gli $\SMEM$.
  % Per semplicità denotiamo con $\gamma$ il numero di accessi al
  % pannello e, nel caso della componente \texttt{RA-BV}, si ha che il calcolo
  % complessivo delle lunghezza è proporzionale a:
  % \begin{equation}
  %   \label{eq:msthr2bv}
  %   \mathcal{O}(N\gamma)
  % \end{equation}
  % Mentre, con l'uso della componente \texttt{RA-SLP}, è proporzionale a:
  % \begin{equation}
  %   \label{eq:msthr2slp}
  %   \mathcal{O}\left(N\gamma\log (NM)\right)
  % \end{equation}
\end{itemize}
Tali complessità teoriche sono fortemente sovrastimate. \\
Facendo una stima complessiva, si può ipotizzare come la struttura
\texttt{MAP-BV 
+ THR-BV + RA-SLP + PERM + PHI}, a causa della maggior lentezza in fase di
mapping e di accesso al pannello per il calcolo delle lunghezze, sia quella con
prestazioni peggiori in tempo. Mentre, per il ragionamento inverso, la
struttura 
\texttt{MAP-INT + THR-INT + RA-BV + PERM + PHI} si ritiene sia quella con le
migliori performance, dal punto di vista del tempo macchina.\\
In termini di memoria la struttura
\texttt{MAP-INT + THR-INT + RA-SLP + PERM + PHI} risulta essere la più
vantaggiosa mentre quella
\texttt{MAP-BV + THR-BV + RA-BV + PERM + PHI} la peggiore, per le stime sulle
singole componenti (usando i bitvector sparsi per mapping/threshold e non
usando l'$\,\SLP$ per il random access). 
\begin{algorithm}
  \scriptsize
  \begin{algorithmic}[1]
    \Function{external\_matches}{$z$}
    \State $ms_{row}\gets [0..0],\,\,ms_{len}\gets [0..0]$
    \Comment vettore $MS$ di lunghezza $|z|$
    \State $curr_{row}\gets
    rlpbwt[0].samples_{end}[|rlpbwt[0].samples_{end}|-1]$
    \State $curr_{index}\gets curr_{row}$
    \State  $curr_{run}\gets \ITR(curr_{index},0)$ \textbf{oppure}
    $curr_{run}\gets \rank_h^0(curr_{index})$    
    \State $symb\gets \GS(start_0, curr_{run})$
    \Comment \textbf{Costruzione righe dell'array $MS$}
    \For {\textit{every} $k\in[0, |z|)$}

    \If{$z[i]=symb$}
    \State $ms_{row}[k]\gets curr_{row}$
    \State \hspace{-1.1mm}\textbf{if} $k\neq |z|-1$ \textbf{then}
    $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},z)$ 
    \Else
    \State  $curr_{thr}\gets t_k[curr_{run}]$ \textbf{oppure}
    $curr_{thr}\gets \rank_t^k(curr_{index})$ 
    \State $force_{down} \gets \top$\textit{ sse l'indice è sovrapposto a una
    threshold non in coda di run}
    \State $force_{down} \gets \top$\textit{ sse l'indice è sovrapposto a una
    threshold in coda di run e $\mathtt{DOWN}(\ldots)=\top$}
    \If{$|samples_{beg}^k|=1$}
    \State $ms_{row}[k]\gets M$
    \If{$k\neq |z|-1$}
    \State $curr_{row}\gets
    rlpbwt[k+1].samples_{end}[|rlpbwt[k+1].samples_{end}|-1]$
    \State $curr_{index}\gets M-1$
    \State $curr_{run}\gets \ITR(curr_{index},k+1)$ \textbf{oppure}
    $curr_{run}\gets \rank_h^{k+1}(curr_{index})$
    \State $symb\gets \GS(start_{k+1}, curr_{run})$
    \EndIf
    \ElsIf{$(curr_{run}\neq 0 \land curr_{run}=curr_{thr}\land \neg down)\lor
    curr_{run}=|samples_{beg}^k|-1$} 
    \State $curr_{index}\gets p_k[curr_{run}]-1$ \textbf{oppure}
    $curr_{index}\gets \select_h^{k}(curr_{run})$
    \State $curr_{row}\gets samples_{end}^k[curr_{run}-1]$
    \State $ms_{row}[k]\gets curr_{row}$
    \State \textbf{if} $k\neq |z|-1$ \textbf{then}
    $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},z)$ 
    % \If{$k\neq |z|-1$}
    % \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    % z)$ 
    % \EndIf
    \Else
    \State $curr_{index}\gets  p_k[curr_{run}+1]$ \textbf{oppure}
    $curr_{index}\gets \select_h^{k}(curr_{run}+1)+1$
    \State $curr_{row}\gets samples_{beg}^k[curr_{run}+1]$
    \State $ms_{row}[k]\gets curr_{row}$
    \State \textbf{if} $k\neq |z|-1$ \textbf{then} $(curr_{index},\,\,curr_{run},
    \,\,symb)\gets \UP(k, curr_{index}, z)$ 
    % \If{$k\neq |z|-1$}
    %  \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},
    % z)$ 
    % \EndIf
    \EndIf
    \EndIf
    \EndFor
    \For {\textit{every} $k\in[0,|z|)$}
    \Comment \textbf{Costruzione lunghezze dell'array $MS$}
    \If{$ms_{row}[k] = M$}
    \State $ms_{len}[k]\gets 0$
    \ElsIf{$k\neq 0\land ms_{row}[i]=ms_{row}[i-1]\land
    ms_{len}[i-1]\neq 0$}
    \State $ms_{len}[i]\gets ms_{len}[i-1]+1$
    \Else
    \Comment $ra$ effettua il random access con la componente \texttt{RA-BV} o
    \texttt{RA-SLP} 
    \State $tmp_{index}\gets i,\,\,tmp_{len}\gets 0$
    \While {$tmp_{index}\geq 0 \land z[tmp_{index}]=ra(ms_{row}[k],
    tmp_{index})$}
    \State $tmp_{index}\gets tmp_{index}-1,\,\,tmp_{len}\gets tmp_{len}+1$
    \EndWhile
    \State $ms_{len}[k]\gets tmp_{len}$
    \EndIf
    \EndFor
    \For {\textit{every} $k\in[0,|z|)$}
    \Comment \textbf{Calcolo dei match da $MS$}
    \If{$(ms_{len}[k]>1 \land ms_{len}[k]\geq ms_{len}[k+1])\lor(k = |z|-1 \land
    ms_{len}[k]\neq 0$}
    \State \textit{report dello SMEM terminante in colonna $k$}
    \State \textit{SMEM di lunghezza $ms_{len}[k]$ con la riga $ms_{row}[k]$ e
    quelle estese da essa tramite} \texttt{PHI}
    \EndIf
    \EndFor
    \EndFunction

    
    \Function {down}{$pos, prev, next$}
    \State \textit{si usano le LCE queries o il random access per calcolare il
    suffisso comune più lungo tra quelli delle righe}
    \State \textit{$pos$/$prev$ e
    $pos$/$next$ fino alla colonna precedente a quella corrente} 
    \State \textit{se il secondo è maggiore o uguale al primo ritorna $\top$,
    altrimenti $\bot$} 
    \EndFunction
  \end{algorithmic}
  \caption{\footnotesize{Calcolo degli SMEM con aplotipo esterno con componenti
  \texttt{MAP-INT/BV},
  \texttt{THR-INT/BV} (i cui usi diversificati di entrambe le componenti sono
  segnalati con ``oppure''), \texttt{RA-BV/SLP}, \texttt{PERM} e \texttt{PHI}.}}    
  \label{algo:matchthr}
\end{algorithm}
\begin{algorithm}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{update}{$k, curr_{index}, z$}
    \State $curr_{index}\gets \W(k, curr_{index}, z[k])$
    \State $curr_{run}\gets \ITR(curr_{index},k+1)$ \textbf{oppure}
    $curr_{run}\gets \rank_h^{k+1}(curr_{index})$
    \State $symb\gets \GS(start_{k+1}, curr_{run})$
    \State \textbf{return} $(curr_{index},\,\,curr_{run},\,\,symb)$
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per l'update con componenti \texttt{MAP-INT} e
  \texttt{MAP-BV}.} 
  \label{algo:updatems}
\end{algorithm}
\subsubsection{Calcolo dell'array delle matching statistics tramite LCE query}
Grazie all'uso delle $\LCE$ query, è possibile calcolare
l'array 
delle matching statistics in un solo scorrimento da sinistra a
destra sull'aplotipo query. Infatti, è possibile usare le $\LCE$ query per
calcolare non solo quale nuova 
riga scegliere in caso di mismatch con l'aplotipo
query ma anche di computare la lunghezza
del suffisso comune tra essa e l'aplotipo query. In tal modo, si calcolano nello
stesso momento sia i valori di $\MS[i].\row$ che di $\MS[i].\len$ (e di
conseguenza anche gli $\SMEM$).\\
Tale soluzione è quindi relativa alle seguenti strutture dati composte:
\begin{itemize}
  \item \texttt{MAP-INT + LCE + PERM + PHI}
  \item \texttt{MAP-BV + LCE + PERM + PHI}
\end{itemize}
Con la notazione $\lce(k, x, y)$,
si indica il calcolo della $\LCE$ query, terminante in colonna $k-1$ (quindi
escludendo la colonna 
$k$-esima), tra le righe del pannello di indice $x$ e
indice $y$.\\ 
Per convenzione, si inizia la computazione dall'ultima 
riga della prima colonna.
Si supponga di avere calcolato l'array $\MS$, per una query $z$ rispetto al
pannello $X$, fino alla
colonna $k-1$. Sia $i$ 
l'indice di riga sulla matrice $\PBWT$ al quale si è arrivati mediante il
mapping, avendo che tale riga corrisponde a quella, in $X$, che ha il più lungo
suffisso 
comune con 
$z[0,k-1]$. Assumendo che l'indice $i$ appartenga alla run $r$, di simboli
$\sigma$, con testa di indice $s$ e coda di indice $e$, si hanno diversi casi:
\begin{enumerate}
  \item $z[k]=y_i^k[k]=\sigma$, quindi la riga $i$ può essere usata per
  estendere il 
  match e per 
  proseguire col mapping in colonna $k+1$, avendo che
  $\MS[k].\row=\MS[k-1].\row$ e $\MS[k].\len=\MS[k-1].\len+1$
  \item $z[k]\neq y_i^k[k]=\sigma$ e si ha una sola run in colonna $k$, avendo
  che 
  non si possono avere match in quella colonna. Per convenzione, si
  memorizzano $\MS[k].\row = M$ e $\MS[k].\len=0$ e si ricomincia, in
  colonna 
  $k+1$, dall'ultima posizione, che corrisponde, nel pannello originale,
  alla riga specificata dal valore del prefix array sample della coda
  dell'ultima run 
  \item $z[k]\neq y_i^k[k]=\sigma$ ma si hanno anche altre run, dovendo quindi
  scegliere 
  la nuova riga da seguire. Si ha che il più lungo suffisso di $z[0,k]$, che è
  anche suffisso di $x_0[0,k],\ldots, x_{M-1}[0,k]$, è uno tra:
  \begin{itemize}
    \item $x_{a_k[s-1]}$, se $s\neq 0$, ovvero la riga del pannello
    che corrisponde alla coda della run precedente a quella corrente
    \item $x_{a_k[e+1]}$, se $e\neq M-1$, ovvero la riga del pannello
    che corrisponde alla testa della run successiva a quella corrente
  \end{itemize}
  Questo fatto è dovuto all'ordinamento lessicografico
  inverso, che si ha per la costruzione della $\PBWT$.
  Avendo quindi i prefix array sample, che ci dicono a quale riga nel
  pannello corrispondano tali valori, e conoscendo $\MS[k-1].\row$, è possibile
  calcolare $\lce(k,\MS[k-1].\row, a_k[s-1])$ e $\lce(k,\MS[k-1].\row,
  a_k[e+1])$. Si sceglie il suffisso comune più lungo tra le due, ovvero il più
  lungo risultato tra le due funzioni $\lce$, e la riga
  corrispondente per proseguire. Si ha quindi $\MS[k].\row=a_k[s-1]$ o
  $\MS[k].\row=a_k[e+1]$ (in memoria nella componente \texttt{PERM}). In merito
  al campo $\len$, assumendo che la lunghezza 
  maggiore delle due $\LCE$ query sia $l$, si ha che:
  \begin{equation}
    \label{eq:mslce1}
    \MS[k].\len=\min(\MS[k-1].\len, l)+1
  \end{equation}
  Questa assegnazione si ha in quanto la $\LCE$ query potrebbe restituire un
  valore più lungo dell'effettivo 
  match con la query $z$. Si sceglie, di conseguenza, il minimo tra le due
  lunghezze per considerare l'overlap, 
  ottenendo l'effettiva lunghezza del suffisso comune tra $z$ e la nuova riga
  scelta, fino alla colonna $k-1$, incrementandolo di uno per conteggiare il
  match ottenuto in colonna $k$ 
\end{enumerate}
\begin{esempio}
  Si riprende l'esempio \ref{es:thr}, visto per il calcolo di $\MS[i].\row$,
  dopo un mismatch, tramite threshold. \\
  Senza usare le threshold, si dovrebbero
  calcolare, avendo $\MS[1].\row=19$ e $\MS[1].\len =2$:
  \[\lce(2, x_{19}, x_{16}) = \mbox{"01"} \implies|\lce(2, x_{19}, x_{16})|=2\]
  \[\lce(2, x_{19}, x_{17}) = \mbox{"1"} \implies|\lce(2, x_{19}, x_{17})|=1\]
  Come verificabile dal pannello presente all'esempio \ref{es:pbwt1}.\\
  Si ha quindi che $\MS[2].\row=16$ e che:
  \[\MS[2].\len=\min(\MS[1].\len, 2)+1=2+1=3\]
\end{esempio}
\noindent
Con questa soluzione, il cui pseudocodice è consultabile all'algoritmo
\ref{algo:matchlce}: 
\begin{itemize}
  \item non si necessita di tenere in memoria le informazioni per le
  threshold
  \item è possibile il calcolo dell'array $\MS$ in una singola scansione della
  query
  \item non si necessita di memorizzare l'intero array $\MS$, ma solamente
  quattro variabili relative alla coppia
  $(\row,\len)$ corrente e a quella precedente. Infatti, per computare i valori
  in 
  colonna $k+1$ dell'array $\MS$ e gli $\SMEM$ terminanti in colonna $k+1$, si
  necessita solo delle informazioni in colonna $k$. \\
  \textit{Per facilità di
    lettura si è lasciato, nello pseudocodice, l'uso dell'intero array $\MS$}
\end{itemize}
Dal punto di vista della complessità temporale, per il calcolo dell'array $\MS$
tramite $\LCE$ query, si hanno variazioni solo in base alla componente per il
mapping.  
Nel caso della componente \texttt{MAP-INT}, avendo $\rho$ numero medio di run
per colonna, dovendo iterare la query, fare il mapping e usare la
componente \texttt{LCE}, si 
ha un tempo proporzionale a: 
\begin{equation}
  \label{eq:mslce22}
  \mathcal{O}(N(\log \rho+\log (NM)))
\end{equation}
Mentre, nel caso dell'uso della componente \texttt{MAP-BV}, si ha tempo
proporzionale a:
\begin{equation}
  \label{eq:mslce3}
  \mathcal{O}\left(N\left(\log \frac{M}{\rho}+\log (NM)\right)\right)
\end{equation}
Infine, per il calcolo di tutte le righe del pannello per cui si ha uno
$\SMEM$, bisogna considerare quando analizzato per la componente
\texttt{PHI}.\\ 
Si deduce come la struttura composta \texttt{MAP-INT + LCE + PERM + PHI}
sia, a 
livello di tempo macchina, la soluzione più vantaggiosa usando la componente
\texttt{LCE}. Tale soluzione risulta essere anche la migliore in
termini di memoria, per quanto discusso in merito a intvector compressi e
bitvector sparsi nella sezione \ref{sec:comp}.\\ 
Si vedrà, sperimentalmente, nel Capitolo \ref{reschap}, il
confronto con le altre strutture dati. Una prima intuizione è quella
che, usando le $\LCE$ query, si hanno sicuramente, a parità di componenti per
il mapping, tempi peggiori rispetto
all'uso della componente \texttt{RA-BV}, come mostrato dalle complessità
temporali. Un confronto con le strutture basate su \texttt{RA-SLP} risulta
più complesso da analizzare, limitandosi alle stime asintotiche e
quindi è necessaria un'analisi sperimentale.
\begin{algorithm}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{matches\_ms\_lce}{$z$}
    \State $ms_{row}\gets [0..0],\,\,ms_{len}\gets [0..0]$
    \Comment array $MS$ di lunghezza $|z|$
    \State $curr_{row}\gets
    rlpbwt[0].samples_{end}[|rlpbwt[0].samples_{end}|-1],\,\,curr_{index}\gets
    curr_{row}$ 
    \State $curr_{run}\gets \ITR(curr_{index},0)$ \textbf{oppure}
    $curr_{run}\gets rank_h^0(curr_{index})$  
    \State $symb\gets \GS(start_0, curr_{run})$
    \Comment \textbf{Costruzione dell'array $MS$}
    \For {\textit{every} $k\in[0, |z|)$}
    \If{$z[i]=symb$}
    \State $ms_{row}[k]\gets curr_{row}$
    \State \hspace{0.1mm}\textbf{if} $k=0$ \textbf{then} $ms_{len}[k] \gets 1$ \textbf{else}
    $ms_{len}[k] \gets ms_{len}[k-1]+1$
    \State \textbf{if} $k\neq |z|-1$ \textbf{then}
    $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},z)$
    % \If{$k\neq |z|-1$}
    % \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},
    % z)$ 
    % \EndIf
    \Else 
    \If{$|samples_{beg}^k|=1$}
    \State $ms_{row}[k]\gets M$
    \State $ms_{len}[k]\gets 0$
    \If{$k\neq |z|-1$}
    \State $curr_{row}\gets
    rlpbwt[k+1].samples_{end}[|rlpbwt[k+1].samples_{end}|-1]$
    \State $curr_{index}\gets M-1$
    \State {\scriptsize{$curr_{run}\gets \ITR(curr_{index},k+1)$ \textbf{oppure}
    $curr_{run}\gets rank_h^{k+1}(curr_{index})$}}
    \State $symb\gets \GS(start_{k+1}, curr_{run})$
    \EndIf
    \Else
    \If{$curr_{run}=|samples_{beg}^k|-1$}
    \State $curr_{index}\gets p_k[curr_{run}-1]$ \textbf{oppure}
    $curr_{index}\gets select_h^k(curr_{run})$
    \State $prev_{row}\gets
    samples_{end}^k[curr_{run}-1]$ 
    \State $lce\gets \lce(k, curr_{row}, prev_{row})$
    \State $ms_{row}[k]\gets prev_{row},\,\,curr_{row}\gets prev_{row}$
    \State \textbf{if} $k=0$ \textbf{then} $ms_{len}[k] \gets 1$ \textbf{else}
    $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$ 
    % \If{$k=0$}
    % \State $ms_{len}[k] \gets 1$
    % \Else
    % \State $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$
    % \EndIf
    \State \textbf{if} $k\neq |z|-1$ \textbf{then}
    $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},z)$  
    % \If{$k\neq |z|-1$}
    % \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},
    % z)$  
    % \EndIf    
    \ElsIf{$curr_{run}=0$}
    \State $curr_{index}\gets p_k[curr_{run}+1]$ \textbf{oppure}
    $curr_{index}\gets select_h^k(curr_{run}+1)+1$
    \State $next_{row}\gets samples_{beg}^k[curr_{run}+1]$ 
    \State $lce\gets \lce(k, curr_{row}, next_{row})$
    \State $ms_{row}[k]\gets next_{row},\,\,curr_{row}\gets next_{row}$
    \State \textbf{if} $k=0$ \textbf{then} $ms_{len}[k] \gets 1$ \textbf{else}
    $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$
    % \If{$k=0$}
    % \State $ms_{len}[k] \gets 1$
    % \Else
    % \State $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$
    % \EndIf
    \State \textbf{if} $k\neq |z|-1$ \textbf{then} $(curr_{index},\,\,
    curr_{run},\,\,symb)\gets \UP(k, curr_{index},z)$  
    % \If{$k\neq |z|-1$}
    % \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},
    % z)$ 
    % \EndIf
    \Else
    \State $prev_{row}\gets samples_{end}^k[curr_{run}-1],\,\,next_{row}\gets
    samples_{beg}^k[curr_{run}+1]$ 
    \State $lce\gets \max (|\lce(k, curr_{row}, prev_{row})|, |\lce(k,
    curr_{row}, next_{row})|)$
    \State $curr_{row}\gets lce_{row}$
    \Comment $lce_{row}$ è l'indice della riga con \textit{LCE query} più
    lunga 
    \State $ms_{row}[k]\gets curr_{row}$
    \State \textbf{if} $k=0$ \textbf{then} $ms_{len}[k] \gets 1$ \textbf{else}
    $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$
    % \If{$k=0$}
    % \State $ms_{len}[k] \gets 1$
    % \Else
    % \State $ms_{len}[k] \gets min(ms_{len}[k-1], |lce|)+1$
    % \EndIf
    \State \textbf{if} $k\neq |z|-1$ \textbf{then}
    $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k, curr_{index},z)$ 
    % \If{$k\neq |z|-1$}
    % \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets \UP(k,curr_{index},
    % z)$ 
    % \EndIf
    \EndIf
    \EndIf
    \EndIf
    \EndFor
    
    \For {\textit{every} $k\in[0,|z|)$}
    \Comment \textbf{Calcolo dei match da $MS$}
    \If{$(ms_{len}[k]>1 \land ms_{len}[k]\geq ms_{len}[k+1])\lor(k = |z|-1 \land
    ms_{len}[k]\neq 0$}
    \State \textit{report degli SMEM di lunghezza $ms_{len}[k]$, terminanti in
    colonna $k$}
    \State \textit{con la riga $ms_{row}[k]$ e quelle estese da essa tramite
    la componente \texttt{PHI}} 
    \EndIf
    \EndFor
    \EndFunction
    
  \end{algorithmic}
  \caption{\footnotesize{Calcolo degli SMEM con aplotipo esterno con componenti
  \texttt{MAP-INT/BV} (i cui usi diversificati sono segnalati con ``oppure''),
  \texttt{LCE}, \texttt{PERM} e \texttt{PHI}.}}
  \label{algo:matchlce}
\end{algorithm}
% LocalWords:  pseudocodice
