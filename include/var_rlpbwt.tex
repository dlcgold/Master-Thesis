\section{Perché la compressione run-length}
Prima di proseguire con la spiegazione dettagliata delle varianti della
\textbf{RLPBWT} è bene dare 
una prima motivazione al perché si sia ritenuto utile sviluppare una variante
\textbf{run-length encoded} della \textbf{PBWT}.\\
Citando direttamente il paper di Durbin \cite{pbwt}:
\begin{center}
  \textit{Furthermore we can also expect the y arrays to be strongly run-length
    compressible. This is because population genetic structure means that there
    is local correlation in values due to linkage disequilibrium, which means
    that haplotypes with similar prefixes in the sort order will tend to have
    the same allele values at the next position, giving rise to long runs of
    identical values in the y array. So the PBWT can easily be stored in smaller
    space than the original data.} 
\end{center}
Quindi il risultato atteso è quello per cui aplotipi simili, che, ad ogni step.
saranno consecutivi nel riordinamento, è molto probabile presentino lo stesso
allele nella colonna di cui si sta in quel momento calcolando la
permutazione. Ne segue che, all'interno della \textit{matrice PBWT}, è molto
probabile che si abbiano lunghe run di simboli $\sigma=0$ e di simboli
$\sigma=1$.\\ 
Si noti quindi che si ottiene quindi il medesimo risultato atteso avuto con
la \textit{BWT}, avendo che caratteri uguali è molto probabile vengano posti in
posizioni consecutive all'interno della \textit{BWT} stessa. Si hanno quindi le
stesse premesse che hanno portato alla \textit{RLBWT}, considerando, inoltre,
che,
come in quel caso, non si tratta solo di memorizzare la struttura con
compressione run-length ma di lavorare direttamente con la struttura dati
compressa, risolvendo il problema del calcolo degli \textit{SMEM} senza
decomprimere la struttura dati.
\section{Introduzione alle varianti della RLPBWT}
Lo sviluppo di questo progetto di tesi è stato tale per cui si sono sviluppate
varie implementazioni della \textbf{RLPBWT}. Tali varianti non sono da
intendersi ugualmente valide ma corrispondono al percorso evolutivo avuto
nell'ultimo anno di studio e ricerca in merito. Riassumendo il tutto si
vedranno:
\begin{itemize}
  \item una prima implementazione \textit{na\"{i}ve}, detta appunto
  \textbf{RLPBWT na\"{i}ve}, che corrisponde al primo tentativo di studio. Tale
  versione è stata 
  fortemente ispirata dai risultati introduttivi di Gagie et
  al. \cite{tricks}. Questa soluzione non 
  permette di sapere quali righe del pannello presentano uno \textit{SMEM},
  terminante in una certa colonna, ma solo quante
  \item si è quindi iniziato ad introdurre l'uso dei \textit{bitvector sparsi},
  con la 
  \textbf{RLPBWT con bitvectors}, il cui funzionamento è pressoché analogo alla
  versione \textit{na\"{i}ve}, al più dell'uso di tali strutture succinte per il
  funzionamento del mapping. Questa soluzione non
  permette di sapere quali righe del pannello presentano uno \textit{SMEM},
  terminante in una certa colonna, ma solo quante
  \item il primo sostanziale ``cambio di paradigma'', si ha avuto con la
  \textbf{RLPBWT con pannello denso}, variante in cui, oltre all'uso dei
  \textit{bitvectors} si è proceduto al calcolo degli \textit{SMEM} tramite
  \textit{matching statistics} e \textit{LCE query}. Questa soluzione permette
  di sapere l'indice di una sola riga per la quale si sta avendo uno
  \textit{SMEM}, terminante in una certa colonna, con il pattern 
  \item migliorando la soluzione precedente con l'uso dell'\textit{SLP} per la
  memorizzazione del pannello si è ottenuta la \textbf{RLPBWT con SLP}. Questa
  soluzione permette di sapere l'indice di una sola riga per la quale si sta
  avendo uno \textit{SMEM}, terminante in una certa colonna, con il pattern 
  \item infine, con l'implementazione delle \textbf{funzioni}
  $\boldsymbol\varphi$ e $\boldsymbol\varphi^\mathbf{-1}$ per la 
  \textbf{RLPBWT}, si è permesso di estendere i risultati delle ultime due
  varianti in modo da ottenere tutti gli \textit{SMEM} con tutti gli indici
  delle righe per cui si ha il medesimo \textit{SMEM} con il pattern
\end{itemize}
Si può quindi iniziare ad apprezzare il percorso evolutivo e incrementale
vissuto con questo progetto.
