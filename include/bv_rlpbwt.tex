\section{RLPBWT con bitvectors}
Al fine di compiere un ulteriore passo verso la formulazione di una struttura
dati efficiente dal punto di vista dello spazio in memoria per la
\textbf{RLPBWT}, si è provveduto a modificare la versione \textit{naive} al fine
di introdurre l'uso dei \textbf{bitvectors}. Questo è stato fatto al fine di
ottenere una rappresentazione in memoria della stessa che fosse ancora più
efficiente. Come si vedrà questa versione intermedia non comporterà un
miglioramento effettivo del consumo di memoria ma permetterà di avere la base su
cui costruire le versioni successive.\\
L'idea è quindi quella di sostituire, data una colonna $k$, quanto necessario a
rappresentare le run (ovvero il vettore $p_k$ della variante naive) e quanto
necessario a permettere il mapping (ovvero il vettore $uv_k$).\\
In primis, per poter localizzare le run nella $k$-esima colonna, si è scelto di
usare un \textit{bitvector}, che denominiamo per praticità $h_k$, tale che
$|h_k|=N$. Formalmente si ha che:
\[h_k[i]=
  \begin{cases}
    1&\mbox{se } y^k[i]\neq y^k[i+1]\lor i==N-1\\
    0&\mbox{altrimenti}
  \end{cases},\forall i\in \{0,\ldots,N-1\}
\]
Informalmente, quindi, si ha che si ha 1 in $h_k$ in tutti gli indici
corrispondenti alla fine di una run.\\
Empiricamente ci si aspettano ``poche'' run all'interno di una colonna della
\textit{matrice PBWT}, per quanto già discusso nella sezione
\ref{secpbwt}. Avendo poche run ci si aspetta anche ``pochi'' 1 all'interno di
$h_k$, di conseguenza si è optato per usare gli \textbf{sparse bitvector} per la
memorizzazione in memoria di ogni $h_k$, ricordando che, secondo quanto
riportato per la libreria \textit{SDSL} \cite{sdsl}, tale variante richiede in
memoria, indicando con $r$ il numero di run:
\[\approx r\left(2+\log\frac{|h_k|}{r}\right)\mbox{ bit}\]
\textbf{VERIFICARE CHE SIANO BITS}\\
Più elaborata è la rappresentazione dei vettori $u_k$ e $v_k$. In questo caso si
è deciso, a differenza della rappresentazione unica vista nella \textit{RLPBWT
  naive}, di optare per due \textit{sparse bitvector}. In particolare, per il
vettore $u_k$, tale che $|u_k|=c[k]$, si ha che:
\[u_k[i]=
  \begin{cases}
    1&\mbox{se }i \mbox{ è il numero di simboli che contiene la
    }rank_{u_k}(i)\mbox{-esima run di 0}\\
    0&\mbox{altrimenti}
  \end{cases},
\]
\vspace{-5mm}
\[\forall i\in\{0,\ldots,|u_k|-1\}\]
Analogamente si definisce $v_k$, tale che $|v_k|=N-c[k]$ come:
\[v_k[i]=
  \begin{cases}
    1&\mbox{se }i \mbox{ è il numero di simboli che contiene la
    }rank_{v_k}(i)\mbox{-esima run di 1}\\
    0&\mbox{altrimenti}
  \end{cases},
\]
\vspace{-5mm}
\[\forall i\in\{0,\ldots,|v_k|-1\}\]
Si noti che:
\[rank_{h_k}(|h_k-1|)+1=([rank_{u_k}(|u_k-1|)+1)+[rank_{v_k}(|v_k-1|)+1\]
Ovvero il numero di 1 presenti in $h_k$ è pari alla somma di quelli presenti in
$u_k$ e $v_k$. Ne segue che, anche per questi ultimi due vettori, la scelta di
usare \textit{sparse bitvector} per la loro memorizzazione sia giustificata
dalla poca quantità, empiricamente, di simboli $\sigma=1$.\\
Si vede un esempio chiarificatore.
\begin{esempio}
  \label{es:bv1}
  Sia data la seguente colonna:
  \[y^5=00101111000000000000\]
  Si ha quindi che:
  \[h_5=01110001000000000001\]
  Avendo appunto un numero di run pari a:
  \[rank_{h_5}(|h_5|)+1=4+1=5\]
  In merito alle run composte da simboli $\sigma=0$ si ha che:
  \[u_5=011000000000001\]
  Avendo infatti che si segnalano:
  \begin{itemize}
    \item la prima run composta da due simboli $\sigma=0$
    \item la seconda run composta da un solo simbolo $\sigma=0$
    \item la terza run composta da dodici simboli $\sigma=0$
  \end{itemize}
  Parlando invece di $v_5$ si ha:
  \[v_5=10001\]
  Avendo che:
  \begin{itemize}
    \item la prima run è composta da un solo simbolo $\sigma=1$
    \item la seconda run è composta da quattro $\sigma=1$
  \end{itemize}
\end{esempio}
Le restanti informazioni, ovvero, per la colonna $k$, il valore $c[k]$, il
booleano $start^k$ e l'LCP array $l_k$ sono le medesime della variante
\textit{naive} della \textit{RLPBWT} (motivo per quale solo a breve si
tratterà l'algoritmo di match).\\
Lo pseudocodice relativo alla costruzione della colonna $k$-esima della
\textbf{RLPBWT con bitvector} è disponile all'algoritmo \ref{algo:cosbv} (dove
sono presenti anche le istruzioni per le varianti che verranno trattate in
seguito).\\
\textbf{CAPIRE SE METTERE UNO PSEUDO A PARTE}\\
Bisogna spiegare come, data un indice di aplotipo $i\in\{0,\ldots,N-1\}$ e una
colonna $k$, estrarre $u'_k[i]$ e $v'_k[i]$, ovvero come se si stesse usando la
\textit{PBWT} classica, a partire dagli attuali $u_k[i]$ e $v_k[i]$. Ovviamente,
se $i=0$, si ha che $u'_k[0]=v'_k[0]=0$. In caso contrario bisogna capire la run
in cui si trova l'indice $i$. Questo si ottiene direttamente sfruttando $h_k$:
\[run = rank_{h_k}(i)\]
Una volta calcolato l'indice di run si hanno tre possibilità:
\begin{enumerate}
  \item si ha che $run=0$ e una run di simboli $\sigma=b$, con $b\in\{0,1\}$
  allora:
  \[(u,v)=
    \begin{cases}
      (i,0)&\mbox{se } b=0\\
      (0,i)&\mbox{altrimenti}
    \end{cases}
  \]
  \item si ha che $run=1$ e una run di simboli $\sigma=b$, con $b\in\{0,1\}$. In
  tal caso bisogna per prima cosa individuare l'indice di inizio della seconda
  run, sfruttando $h_k$:
  \[beg = select_{h_k}(1)+1\]
  A questo punto si ha il numero di simboli della prima run, indicizzata a 0, e,
  calcolando la distanza tra l'indice di riga e quello di inizio della prima
  run, avendo che:
  \[(u,v)=
    \begin{cases}
      (beg,i-beg)&\mbox{se } b=0\\
      (i-beg,beg)&\mbox{altrimenti}
    \end{cases}
  \]
  \item si ha che $run=j$, con $j\in\{2,r-1\}$. Anche in questo caso  si procede
  calcolando l'indice di inizio della run:
  \[beg = select_{h_k}(run)+1\]
  e l'offset rispetto all'indice $i$ dato:
  \[offset = i-beg\]
  Poi, sfruttando la solita dicotomia fornita dal caso binario in studio, si
  hanno due casi: 
  \begin{enumerate}
    \item si è in una run di indice pari.
    Si sfruttano poi $u_k$ e $v_k$ per sapere l'indice della precedente run con
    simboli $\sigma=0$:
    \[pre_u=select_{u_k}\left(\left\lfloor\frac{run}{2}\right\rfloor\right)+1\]
    e quello della run con simboli simboli $\sigma=1$:
    \[pre_v=select_{v_k}\left(\left\lfloor\frac{run}{2}\right\rfloor\right)+1\]
    Si noti che si usa $\frac{run}{2}$ in quanto, essendo in una run di indice
    pari si hanno precedentemente lo stesso numero di run per $\sigma=0$ e per
    $\sigma=1$ e quindi si considera lo stesso numero di ``run'' nei due
    bitvector $u_k$ e $v_k$.\\
    A questo punto, sempre per il ragionamento per cui solo uno tra $u$ e $v$
    non è costante all'interno di una run si ha che o $pre_u$ o $pre_v$ è tale
    costante mentre l'altro valore deve essere calcolato considerando l'offset:
    \[(u,v)=
      \begin{cases}
        (pre_u+offset,pre_v)&\mbox{se } b=0\\
        (pre_u,pre_v+offset)&\mbox{altrimenti}
      \end{cases}
    \]
    \item ci si trova in una run di indice dispari, quindi non si hanno
    precedentemente lo stesso numero di run per i due simboli. Bisogna quindi
    calcolare quante siano tali run. Se la prima run è di zeri:
    \[run_u=select_{u_k}\left(\left\lfloor\frac{run}{2}\right\rfloor\right)+1\]
    \[run_v=select_{v_k}\left(\left\lfloor\frac{run}{2}\right\rfloor\right)\]
    mentre se la prima run non è di zeri si devono invertire i due valori. Si sa
    quindi quali ``run'' considerare sui due bitvector $u_k$ e $v_k$.\\
    Posso quindi procedere come nel caso precedente, avendo:
    \[pre_u=select_{u_k}(run_u)+1\]
    \[pre_v=select_{v_k}(run_v)+1\]
    E potendo quindi restituire:
    \[(u,v)=
      \begin{cases}
        (pre_u,pre_v+offset)&\mbox{se } b=0\\
        (pre_u+offset,pre_v)&\mbox{altrimenti}
      \end{cases}
    \]
  \end{enumerate}
\end{enumerate}
\textbf{SPIEGAZIONE DA MIGLIORARE}
\begin{esempio}
  Si prendano i dati e i risultati ottenuti all'esempio \ref{es:bv1}. Si
  vogliono calcolare $u$ e $v$ per $i=6$.\\
  In primis si ha quindi:
  \[run=rank_{h_5}(6)=3\]:
  \[beg = select_{h_5}(3)+1=3+1=4\]
  \[offset = i-beg=6-4=2\]
  Quindi ci si trova nel terzo caso e, nel dettaglio, avendo una run di
  indice dispari. Si calcolano quindi:
  \[run_u=select_{u_5}\left(\left\lfloor\frac{3}{2}\right\rfloor\right)+1=
    select_{u_5}(1)+1
    =1+1=2\] 
  \[run_v=select_{v_5}\left(\left\lfloor\frac{3}{2}\right\rfloor\right)=
    select_{v_5}(1)=0\] 
  che non andranno invertiti avendo $start^5=\top$.\\
  Si calcolano quindi:
  \[pre_u=select_{u_5}(2)+1=2+1=3\]
  \[pre_v=select_{v_5}(0)+1=0+1=1\]
  Avendo infatti, in totale, tre simboli $\sigma=0$ e un simbolo $\sigma=1$
  prima dell'indice 6.\\ 
  Concludendo, avendo $start^5=\top$:
  \[(u,v)=(pre_u, pre_v + offset)=(3,1+2)=(3,3)\]
\end{esempio}
L'algoritmo per il calcolo di $u$ e $v$, tenendo in considerazione che tale
metodo verrà usato anche nelle varianti che verranno presentate in seguito della
\textit{RLPBWT}, è disponibile all'algoritmo \ref{algo:uvbv}.