\section{Risultati della sperimentazione}
Si presentano ora i risultati quantitativi della sperimentazione effettuata sui
cinque pannelli scelti. Come anticipato, al fine del computo degli $\SMEM$,
avendo un numero 
ridotto di sample a disposizione, si è scelto di estrarre da ognuno 100 sample
da usare come query, riducendo quindi il numero di sample a 4.908.
\subsection{Costruzione delle strutture e calcolo degli SMEM}
Viste le dimensioni di tali pannelli, si ritiene necessario studiare, dal punto
di vista del tempo macchina e dei picchi di memoria necessaria, le varie fasi
della sperimentazione, ovvero:
\begin{itemize}
  \item la fase di preprocessing, necessaria per la preparazione dei
  vari input della $\RLPBWT$, comprendente: 
  \begin{itemize}
    \item la conversione dei file in formato VCF nei file in formato MACs
    \cite{macs}, usato 
    come formato di input nella $\RLPBWT$
    \item l'estrazione del pannello delle query e la creazione del nuovo
    pannello di aplotipi
    \item la produzione dell'$\,\SLP$ del pannello di aplotipi, comprendente
    sia la produzione della stringa unica monodimensionale che l'esecuzione di
    BigRepair e ShapedSlp
  \end{itemize}
  \item la costruzione e serializzazione delle varie strutture dati composte per
  la $\RLPBWT$ e dei file ad hoc per la $\PBWT$
  \item l'esecuzione degli algoritmi per il calcolo degli $\SMEM$
\end{itemize}
\paragraph{Preprocessing.}
In figura \ref{fig:prechr} si possono analizzare le prestazioni delle tre
fasi di preprocessing. I risultati quantitativi sono consultabili alla tabella
\ref{tab:prepmem} e alla tabella \ref{tab:preptime}. La separazione del
pannello con le query risulta essere assolutamente 
ininfluente e, di fatto, anche la conversione tra i due formati per l'input non
necessita particolari considerazioni, come inferibile dai risultati numerici
delle performance. Si segnala che tale conversione 
diventerebbe non necessaria, implementando l'input direttamente da file VCF per
le varie strutture dati relative alla $\RLPBWT$. Inoltre, in un contesto
reale, la costruzione del pannello di query non sarebbe un'operazione
necessaria.\\
Bisogna, però, analizzare la costruzione 
dell'$\,\SLP$. Per quanto quest'operazione sia da svolgersi \textit{una
  tantum}, le richieste in termini di memoria sono nell'ordine delle centinaia
di gigabyte di RAM mentre i tempi di calcolo sono nell'ordine delle
ore. Prendendo in analisi il cromosoma 1, si ha che è richiesto un picco
di 644GB di RAM, avendo che l'intera esecuzione richiede circa 4 ore.
Bisogna considerare che tutti gli strumenti computazionali per la
produzione 
dell'$\,\SLP$ sono studiati per partire da una singola stringa e non da una
matrice. Nuovi sviluppi in questa direzione potrebbero lasciar spazio a diverse
ottimizzazioni. Bisogna, infine, considerare che
questa fase è necessaria solo per quattro delle otto soluzioni studiate per la
$\RLPBWT$, ovvero quelle che utilizzano o la componente \texttt{RA-SLP} o la
componente \texttt{LCE}. 
Inoltre, il fatto che questa costruzione sia necessaria solo una volta 
è cruciale nell'ottica di un confronto con
lo spazio richiesto dall'algoritmo 5 di Durbin, che richiede $13NM$
byte ad ogni esecuzione.\\
In generale, la crescita di memoria richiesta e di tempo, per le tre fasi di
preprocessing, sembra essere proporzionale al numero di siti dei pannelli, come
atteso.
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{img/prep_mem_time.pdf}
  \caption{Picchi di memoria (a) e tempo richiesto (b) per le tre fasi di
    preprocessing dell'input per la $\RLPBWT$, in scala logaritmica.}
  \label{fig:prechr}
\end{figure}
\begin{table}
  \centering
  \small
  \caption{Risultati quantitivi dei picchi di memoria (gigabyte) relativi alle
    fasi di 
    preprocessing per l'input delle varianti della $\RLPBWT$.}
  \label{tab:prepmem}
  \begin{tabular}{c||c|c|c}
    \textbf{Chr} & \textbf{Costruzione SLP} & \textbf{Conversione VCF a MACs}
    & \textbf{Estrazione query}\\
    \hline
    \hline
    \texttt{chr22} & 111 & 5 & 0,0089  \\
    \texttt{chr20} & 183 & 9 & 0,0090 \\
    \texttt{chr18} & 215 & 11 & 0,0090 \\
    \texttt{chr16} & 272 & 13 & 0,0090 \\
    \texttt{chr1} & 644 & 31 & 0,0094 
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \small
  \caption{Risultati quantitivi dei tempi (secondi) relativi alle fasi di
    preprocessing per l'input delle varianti della $\RLPBWT$.}
  \label{tab:preptime}
  \begin{tabular}{c||c|c|c}
    \textbf{Chr} & \textbf{Costruzione SLP} & \textbf{Conversione VCF a MACs}
    & \textbf{Estrazione query}\\
    \hline
    \hline
    \texttt{chr22} & 2542 & 207 & 28 \\
    \texttt{chr20} & 3950 & 320 & 47 \\
    \texttt{chr18} & 4890 & 405 & 64 \\
    \texttt{chr16} & 6104 & 500 & 71 \\
    \texttt{chr1} & 14430 & 1098 & 157
  \end{tabular}
\end{table}
In figura \ref{fig:slpmacschr} si può osservare il vantaggio in termini di
memoria che si ha con l'uso degli $\SLP$, confrontando il peso dei file
MACs con il peso delle grammatiche compresse. Si segnala che il
peso dei vari file MACs include anche diversi header. In tabella
\ref{tab:slpmacs} si possono
confrontare quantitativamente tali risultati, notando come usare l'$\,\SLP$
richieda circa l'1\% della memoria necessaria al file non compresso.
\begin{table}
  \centering
  \caption{Dimensioni, in gigabyte, degli $\SLP$ e dei file MACs
  per i vari pannelli del 1000 Genome Project.}
  \begin{tabular}{c||c|c}
    \textbf{Chr} & \textbf{SLP}
    & \textbf{MACs} \\
    \hline
    \hline
    \texttt{chr22} & 0,04 & 4,84\\
    \texttt{chr20} & 0,06 & 7,98\\
    \texttt{chr18} & 0,08 & 9,97\\
    \texttt{chr16} & 0,10 & 11,91\\
    \texttt{chr1} & 0,22 & 28,44\\
  \end{tabular}
  \label{tab:slpmacs}
\end{table}
È possibile, quindi, apprezzare la compressione di tali
grammatiche.  
Si noti che, essendo la capacità di compressione di un $\SLP$
direttamente correlata alle ripetizioni presenti nella stringa da comprimere, la
dimensione dell'$\,\SLP$ non è perfettamente proporzionale al numero di siti
dei pannelli in analisi. Per riferimento, comprimere il pannello relativo al
cromosoma 1, con una tecnica standard (GZip), richiede 0,5GB.
\begin{figure}
  \centering
  \includegraphics[width=0.7\linewidth]{img/slp_vs_macs_log.pdf}
  \caption{Confronto tra la memoria richiesta dai file MACs e dagli $\SLP$ per i
    pannelli del 1000 Genome Project, in scala
    logaritmica.} 
  \label{fig:slpmacschr}
\end{figure}
\paragraph{Costruzione della struttura.}
Si analizzano, ora, tempi e picchi di memoria per la costruzione delle
strutture dati. Bisogna ricordare che:
\begin{itemize}
  \item nel caso della $\RLPBWT$, per ognuna delle strutture dati
  composte, questa fase prevede la costruzione e la 
  serializzazione dell'intera struttura dati
  \item nel caso della $\PBWT$, questa fase crea unicamente un file
  compresso ad hoc, contenente le strutture base delle $\PBWT$. A partire
  da tale file, in fase di calcolo degli $\SMEM$, verranno calcolati anche
  tutti gli altri indici necessari al calcolo degli stessi, a seconda
  dell'algoritmo usato 
\end{itemize}
Fatte queste doverose premesse, passiamo ad analizzare i risultati.
In figura \ref{fig:maketimememchr} (a) vengono visualizzati i picchi di
memoria richiesti mentre in figura \ref{fig:maketimememchr} (b) i tempi di
calcolo delle strutture. Alla tabelle \ref{tab:makemem} e \ref{tab:maketime} si
riportano i risultati quantitativi in termini di gigabyte e secondi.\\ 
Come anticipato, l'implementazione della $\PBWT$ non calcola e memorizza
tutti gli indici 
necessari al calcolo degli $\SMEM$ in fase di costruzione, avendo quindi
una bassissima richiesta di memoria in questa fase. Discorso diverso si ha
parlando delle strutture dati per la $\RLPBWT$. Le strutture dati composte
\texttt{MAP-INT + RLCP} e \texttt{MAP-BV + RLCP}, dovendo 
memorizzare l'intero insieme degli array $\RLCP$, hanno un elevato
consumo di memoria. Pur utilizzando degli intvector compressi, in modo
analogo a quanto visto, ad esempio, per la componente \texttt{PERM}, si ha
necessità di salvare $NM$ valori interi. Risulta ovvio notare come, in
termini di costruzione, siano le due strutture che non scalano sul numero
di run 
ad aver maggiori richieste di memoria. Proseguendo nell'analisi si ha che
l'utilizzo della componente 
\texttt{MAP-BV} richiede maggior memoria (approssimativamente tra
il 15\% e il 20\% in più) della componente
\texttt{MAP-INT}, coerentemente con quanto analizzato in Sezione
\ref{sec:comp}. In merito, invece, ai tempi di costruzione delle due 
strutture, si 
segnala come i tempi di calcolo della componente \texttt{MAP-BV} siano superiori
rispetto a quelli della \texttt{MAP-INT} (anche in questo caso
approssimativamente tra il 15\% e il 20\% in più), dovendo, ad esempio,
calcolare anche le strutture per le funzioni $\rank$/$\select$ sui bitvector
sparsi. Nel caso della componente 
\texttt{MAP-INT}, invece, l'unica operazione aggiuntiva, rispetto a quelle attese
per una classica popolazione di array di interi, è la fase di compressione degli
stessi. Le analisi effettuate sulle componenti di mapping sono da
ritenersi analoghe per le componenti dedicate alle threshold, in
termini d'uso di bitvector sparsi e intvector compressi.
Tali considerazioni sono valide anche per le altre strutture
composte per la $\RLPBWT$. Infine, confrontando le strutture dati in grado
di computare l'array $\MS$, si aggiungono le considerazioni sulle possibili
strutture per il random access e, nel caso d'uso dell'$\,\SLP$, per l'uso
delle $\LCE$ query. Si nota come l'uso della componente \texttt{RA-BV}
comporti, come atteso, una maggior richiesta di memoria, pur limitata dall'uso
dei bitvector. Sempre in termini di tempi di esecuzione, si ha che la
componente \texttt{RA-BV} deve essere computata in fase di costruzione delle
strutture, comportando un aumento dei tempi di calcolo (meno del 5\% in
più) rispetto alle strutture basate su
\texttt{RA-SLP}/\texttt{LCE}. Confrontando i tempi di  
tutte le varianti, si ha che tutti gli algoritmi di costruzione sono in tempo
proporzionale a $\mathcal{O}(NM)$ ma, come detto, le varianti della
$\RLPBWT$ includono, in questa fase, anche il calcolo degli indici
utili al calcolo degli $\SMEM$. \\
Si conclude che, parlando di $\RLPBWT$, la
struttura composta \texttt{MAP-INT + LCE + PERM + PHI} risulti essere la meno
costosa in termini di memoria, usando la struttura di mapping tramite
intvector compressi e l'$\,\SLP$ (per le $\LCE$ query).
Anche in termini di tempo, per i discorsi fatti sui tempi di calcolo
delle singole componenti, risulta essere la soluzione più vantaggiosa.\\
In generale, si può 
concludere che questo risultato conferma quanto discusso nel capitolo
\ref{metchap}.\\ 
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{img/make_time_mem_paper.pdf}
  \caption{Picchi di memoria (a) e tempi di calcolo (b) per la
    costruzione delle varianti della $\RLPBWT$ e per 
    la $\PBWT$.}
  \label{fig:maketimememchr}
\end{figure}
\begin{table}
  \centering
  \caption{Risultati quantitativi dei picchi di memoria (gigabyte) di
    costruzione delle 
    strutture dati.} 
  \label{tab:makemem}
  \footnotesize
  \subcaption*{\footnotesize{Tabella A: risultati relativi alla \textit{PBWT} e
      alle varianti 
    basate su $\RLCP$ per la $\RLPBWT$.}} 
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{PBWT}
    & \textbf{\texttt{MAP-INT + RLCP}}
    & \textbf{\texttt{MAP-BV + RLCP}}\\
    \hline
    \hline
    \texttt{chr22} & 0,1 & 9 & 11  \\
    \texttt{chr20} & 0,2 & 15 & 18 \\
    \texttt{chr18} & 0,2 & 19 & 23 \\
    \texttt{chr16} & 0,3 & 23 & 27 \\
    \texttt{chr1} & 0,6 & 55 & 65  \\
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: risultati relativi alle varianti basate
      su 
      matching statistics e bitvector sparsi per la
      $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-BV + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-BV + RA-SLP$\cdots$}}
    & \textbf{\texttt{MAP-BV + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 5 & 4 & 4 \\
    \texttt{chr20} & 8 & 7 & 7 \\
    \texttt{chr18} & 10 & 9 & 8  \\
    \texttt{chr16} & 12 & 10 & 10 \\
    \texttt{chr1} & 28 & 24 & 23 \\
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella C: risultati relativi alle varianti basate
      su 
    matching statistics e intvector compressi per la
    $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-INT + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-INT + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-INT + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 3 & 2 & 2 \\
    \texttt{chr20} & 4 & 3 & 3 \\
    \texttt{chr18} & 5 & 4 & 4 \\
    \texttt{chr16} & 6 & 5 & 5 \\
    \texttt{chr1} & 14 & 12 & 11 
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{Risultati quantitativi dei tempi (secondi) di costruzione delle
    strutture dati.} 
  \label{tab:maketime}
  \footnotesize
  \subcaption*{\footnotesize{Tabella A: risultati relativi alla $\PBWT$ e
      alle varianti 
    basate su $\RLCP$ per la \texttt{\RLPBWT}.}} 
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{PBWT}
    & \textbf{\texttt{MAP-INT + RLCP}}
    & \textbf{\texttt{MAP-BV + RLCP}}\\
    \hline
    \hline
    \texttt{chr22} & 136 & 210 & 250 \\
    \texttt{chr20} & 233 & 349 & 407 \\
    \texttt{chr18} & 290 & 417 & 488 \\
    \texttt{chr16} & 412 & 511 & 613 \\
    \texttt{chr1} & 792 & 1145 & 1393
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: risultati relativi alle varianti basate
      su 
      matching statistics e bitvector sparsi per la
      $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-BV + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-BV + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-BV + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 262 & 255 & 240 \\
    \texttt{chr20} & 439 & 424 & 363 \\
    \texttt{chr18} & 521 & 503 & 431 \\
    \texttt{chr16} & 660 & 628 & 533 \\
    \texttt{chr1} & 1472 & 1400 & 1248 
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella C: risultati relativi alle varianti basate
      su 
    matching statistics e intvector compressi per la
    $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-INT + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-INT + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-INT + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 143 & 137 & 115 \\
    \texttt{chr20} & 232 & 219 & 192 \\
    \texttt{chr18} & 288 & 275 & 238 \\
    \texttt{chr16} & 347 & 330 & 285 \\
    \texttt{chr1} & 778 & 739 & 652
  \end{tabular}
\end{table}
\dc{Controllare tutti questi dati}
Sfruttando i metodi offerti dalla SDSL, è possibile studiare
l'occupazione di memoria delle singole componenti trattate nel capitolo
\ref{metchap}. 
In tabella \ref{tab:comp} e in figura \ref{fig:comp}
si riportano, in megabyte, 
le dimensioni delle varie componenti. Si può,
innanzitutto, apprezzare il vantaggio dell'uso della componente
\texttt{RA-SLP/LCE} rispetto alla 
componente \texttt{RA-BV}, avendo che si ha un risparmio di memoria superiore al
90\%. Numericamente tale vantaggio è riportato in tabella
\ref{tab:slppanel}.
\begin{table}
  \centering
  \caption{Vantaggio percentuale dell'uso delle componenti \texttt{RA-SLP/LCE}
    rispetto alla componente \texttt{RA-BV}.}
  \begin{tabular}{c||c|c|c}
    \textbf{Chr} & \textbf{\texttt{RA-SLP/LCE}
                                          (\textit{MB})}
    & \textbf{\texttt{RA-BV} (\textit{MB})} & \textbf{\%}\\
    \hline
    \hline
    \texttt{chr22} & 44 & 628 & 7\\
    \texttt{chr20} & 61 & 1.035 & 6\\
    \texttt{chr18} & 80 & 1.292 & 6\\
    \texttt{chr16} & 98 & 1.544 & 6\\
    \texttt{chr1} & 226 & 3.687 & 6\\
  \end{tabular}
  \label{tab:slppanel}
\end{table}
Si segnala, nuovamente, il
forte vantaggio in memoria nell'utilizzo delle componenti basate su intvector
compressi, rispetto che a quelle basate su sparse bitvector.\\
Si nota, infine, come le componenti \texttt{PERM} e \texttt{PHI} non
presentino particolari criticità dal punto di vista della memoria
richiesta. Terminando l'analisi di tali risultati, senza trattare
nuovamente le componenti per il random access, si ha conferma della
richiesta eccessiva in memoria della componente \texttt{RLCP}.
\dc{Serve altro?}
\begin{figure}
  \centering
    \includegraphics[width=\linewidth]{img/comp_mem.pdf}
  \caption{Memoria occupata dalle singole componenti, avendo sulle ascisse in
    (a) il numero di siti e in (b) il numero di run. }
  \label{fig:comp}
\end{figure}
\begin{table}
  \centering
  \caption{Dimensioni, in megabyte, delle singole componenti per la
    $\RLPBWT$.} 
  \label{tab:comp}
  \subcaption*{\footnotesize{Tabella A: dimensioni delle componenti di
    mapping e threshold usate nelle
    strutture dati per la $\RLPBWT$.}}   
  \begin{tabular}{c||c|c|c|c}
    \textbf{Chr} & \textbf{\texttt{MAP-INT}} & \textbf{\texttt{MAP-BV}}
    & \textbf{\texttt{THR-INT}} & \textbf{\texttt{THR-BV}} \\
    \hline
    \hline
    \texttt{chr22} & 74 & 543 & 36 & 199\\ \hline
    \texttt{chr20} & 109 & 882 & 53 & 322\\ \hline
    \texttt{chr18} & 137 & 1.100 & 61 & 402\\ \hline
    \texttt{chr16} & 167 & 1.320 & 81 & 483\\ \hline
    \texttt{chr1} & 384 & 3.133 & 185 & 1.146
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: dimensioni delle componenti di
      random access, prefix array sample, struttura $\phi$ e reverse longest
      common prefix.} }
 \vspace{+1mm}
  \begin{tabular}{c||c|c|c|c|c}
    \textbf{Chr} & \textbf{\texttt{RA-BV}} & \textbf{\texttt{RA-SLP/LCE}}
    & \textbf{\texttt{PERM}} & \textbf{\texttt{PHI}} & \textbf{\texttt{RLCP}}\\
    \hline
    \hline
    \texttt{chr22} & 628 & 44 & 71 & 89 & 9.095\\ \hline
    \texttt{chr20} & 1.035 & 62 & 104 & 118 & 15.468 \\ \hline
    \texttt{chr18} & 1.292 & 80 & 128 & 147 & 19.223 \\ \hline
    \texttt{chr16} & 1.545 & 99 & 159 & 186 & 22.888\\ \hline
    \texttt{chr1} & 3.687 & 227 & 366 & 411 & 54.588
  \end{tabular}
\end{table}
\paragraph{Calcolo degli SMEM.}
In seguito si ha la discussione dei risultati ottenuti per il calcolo degli
$\SMEM$.\\ 
In figura \ref{fig:smemtimememchr} (a) si riportano i risultati i termini di
picchi di 
memoria durante la computazione degli $\SMEM$. Tali risultati sono
consultabili quantitativamente in tabella \ref{tab:exemem}. Come previsto,
l'algoritmo 
\texttt{matchDynamic} della $\PBWT$ ha le migliori prestazioni
in spazio, calcolando dinamicamente i vari indici necessari al calcolo degli
$\SMEM$ interni. Invece, per quanto riguarda l'algoritmo
5 di Durbin, ovvero l'algoritmo \texttt{matchIndexed}, si confermano le
previsioni 
fatte dall'autore stesso, avendo che la memoria utilizzata è circa $13NM$
byte. Escludendo le strutture \texttt{MAP-INT + RLCP} e \texttt{MAP-BV + RLCP},
si rileva circa un'intero ordine di grandezza in più di memoria rispetto alle
strutture dati composte per la $\RLPBWT$. Parlando di queste ultime, la
differenza tra le varie strutture dati che supportano il calcolo 
dell'array $\MS$ è dovuta, a parità di componente per il mapping (e
conseguentemente della componente per le threshold), dall'uso della componente
\texttt{RA-BV} o della componente \texttt{RA-SLP}/\texttt{LCE},
in modo analogo a quanto visto discutendo il peso in memoria
delle singole componenti.\\
% Interessante è notare il rapporto tra la memoria richiesta dalla \textit{RLPBWT}
% con \textit{SLP} e \textit{LCE} e la \textit{PBWT Indexed}:
% \begin{table}[H]
%   \centering
%   \footnotesize
%   \begin{tabular}{c|c|c|c|c}
%     \textbf{\#Samples} & \textbf{\#Siti}
%     & \textbf{RLPBWT SLP-LCE (\textit{kb})}
%     & \textbf{PBWT Indexed (\textit{kb})} & \textbf{\%}\\
%     \hline
%     4908 & 1055454 & 3058088 & 65975520 & 4.64\\
%     4908 & 1739315 & 4961664 & 108713424 & 4.56\\
%     4908 & 2171378 & 6190684 & 135726084 & 4.56\\
%     4908 & 2596072 & 7430300 & 162257008 & 4.58\\
%     4908 & 6196151 & 17635700 & 387252160 & 4.55
%   \end{tabular}
% \end{table}
% Anche in questo caso le percentuali risultano leggermente peggiori rispetto ai
% pannelli simulati, pur restando risultati molto interessanti.
In figura \ref{fig:smemtimememchr} (b) si riportano, invece, i risultati i
termini di tempo di calcolo. Tali risultati sono
consultabili numericamente in tabella \ref{tab:exetime}. Anche in questo caso
l'algoritmo 
\texttt{matchDynamic} risulta essere il più performante, in quanto studia
contemporaneamente l'intero pannello di query. Parlando di $\RLPBWT$,  la
struttura \texttt{MAP-INT + THR-INT + RA-SLP + PERM + PHI} e la 
struttura 
\texttt{MAP-BV + THR-BV + RA-SLP + PERM + PHI}, a causa delle
frequenti operazioni di random access con la componente
\texttt{RA-SLP} (sia per il calcolo delle lunghezze delle 
matching statistics che per la fase di disambiguazione), richiedono più tempo
di tutte le altre varianti, soprattutto se si pensa alle corrispondenti
varianti con componente \texttt{RA-BV}. L'uso della componente \texttt{RA-SLP}
comporta, infatti, circa venti volte i tempi di calcolo che si hanno usando le
componenti 
basate su
bitvector sparsi e addirittura di circa 45 volte quelli che si hanno usando
le strutture basate su intvector compressi per mapping e threshold. La struttura
\texttt{MAP-INT + LCE + 
  PERM + PHI} e la struttura 
\texttt{MAP-BV + LCE + PERM + PHI} risultano essere, al massimo,
il doppio più lente rispetto all'algoritmo \texttt{matchIndexed}, con una
differenze che diventa quasi trascurabile all'aumentare delle dimensioni del
pannello. Questo è un 
risultato molto interessante, considerando la memoria necessaria
per il calcolo degli $\SMEM$ delle varie implementazioni.\\
Confrontando l'uso delle $\LCE$ query con l'uso della componente
\texttt{RA-BV} si hanno, invece, tempi triplicati nel caso d'uso di componenti
per mapping e 
threshold con bitvector sparsi. Nel caso d'uso degli intvector compressi, si
hanno, d'altro canto, circa sette volte i tempi di 
computazione. A priori delle componenti per mapping e
threshold, l'uso della componente \texttt{RA-SLP} comporta circa sei
volte il tempo d'uso delle $\LCE$ query. Queste ultime analisi comportano
che l'uso del random access su $\SLP$ è la peggior soluzione in
ottica di calcolo delle matching statistics.\\
Concludendo, si può notare come la struttura composta
\texttt{MAP-INT + THR-INT + RA-BV + PERM + PHI}, tra quelle per la
$\RLPBWT$, risulti essere la migliore in termini di tempi di calcolo
mentre la struttura composta \texttt{MAP-INT + LCE + PERM + PHI} sia la
migliore in termini di memoria richiesta. Questo risultato è coerente con quanto
analizzato nel Capitolo \ref{metchap}. Notando come quest'ultima sia circa 10
volte più lenta della soluzione con \texttt{THR-INT} e \texttt{RA-BV}, si può
inferire come la scelta della miglior soluzione per la 
$\RLPBWT$ debba ricadere sulla \texttt{MAP-INT + THR-INT + RA-BV + PERM +
  PHI}, salvo situazioni in cui il risparmio di memoria
fondamentale in fase di analisi dati. 
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{img/exe_time_mem_paper}
  \caption{Picchi di memoria (a) e tempi di esecuzione (b) per il calcolo degli
    $\SMEM$.}
  \label{fig:smemtimememchr}
\end{figure}
\begin{table}
  \centering
  \caption{Risultati quantitativi dei picchi di memoria (gigabyte) di
    costruzione delle 
    strutture dati.} 
  \label{tab:exemem}
  \footnotesize
  \subcaption*{\footnotesize{Tabella A: risultati relativi alla $\PBWT$ e
      alle varianti 
    basate su $\RLCP$ per la $\RLPBWT$.}} 
  \begin{tabular}{c||c|c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{matchIndexed}}
    & \textbf{\texttt{matchDynamic}}
    & \textbf{\texttt{MAP-INT + RLCP}}
    & \textbf{\texttt{MAP-BV + RLCP}}\\
    \hline
    \hline
    \texttt{chr22} & 63 & 0,02 & 9 & 11 \\
    \texttt{chr20} & 104 & 0,03 & 16 & 19 \\
    \texttt{chr18} & 129 & 0,04 & 20 & 23 \\
    \texttt{chr16} & 155 & 0,05 & 24 & 28 \\
    \texttt{chr1} & 369 & 0,10 & 56 & 66 
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: risultati relativi alle varianti basate
      su 
      matching statistics e bitvector sparsi per la
      $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-BV + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-BV + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-BV + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 4 & 3 & 3  \\
    \texttt{chr20} & 6 & 5 & 5 \\
    \texttt{chr18} & 8 & 6 & 6 \\
    \texttt{chr16} & 9 & 8 & 7 \\
    \texttt{chr1} & 22 & 18 & 17 
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella C: risultati relativi alle varianti basate
      su 
    matching statistics e intvector compressi per la
    $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-INT + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-INT + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-INT + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 1,4 & 0,8 & 0,8 \\
    \texttt{chr20} & 2,2 & 1,2 & 1,2 \\
    \texttt{chr18} & 2,8 & 1,6 & 1,5 \\
    \texttt{chr16} & 3,4 & 1,9 & 1,8 \\
    \texttt{chr1} & 8,0 & 4,4 & 4,3                                           
  \end{tabular}
\end{table}
\begin{table}
  \centering
  \caption{Risultati quantitativi dei tempi (secondi) di calcolo degli
    $\SMEM$.}  
  \label{tab:exetime}
  \footnotesize
  \subcaption*{\footnotesize{Tabella A: risultati relativi alla $\PBWT$ e
      alle varianti 
    basate su $\RLCP$ per la $\RLPBWT$.}} 
  \begin{tabular}{c||c|c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{matchIndexed}}
    & \textbf{\texttt{matchDynamic}}
    & \textbf{\texttt{MAP-INT + RLCP}}
    & \textbf{\texttt{MAP-BV + RLCP}}\\
    \hline
    \hline
    \texttt{chr22} & 144 & 17 & 61 & 114 \\
    \texttt{chr20} & 243 & 28 & 89 & 210 \\
    \texttt{chr18} & 305 & 35 & 119 & 255 \\
    \texttt{chr16} & 424 & 42 & 140 & 299 \\
    \texttt{chr1} & 1026 & 93 & 298 & 616
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: risultati relativi alle varianti basate
      su 
      matching statistics e bitvector sparsi per la
      $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-BV + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-BV + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-BV + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 76 & 1305 & 260 \\
    \texttt{chr20} & 121 & 2097 & 385  \\
    \texttt{chr18} & 149 & 2509 & 442  \\
    \texttt{chr16} & 189 & 3252 & 640 \\
    \texttt{chr1} & 419 & 7531 & 1278 
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella C: risultati relativi alle varianti basate
      su 
    matching statistics e intvector compressi per la
    $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-INT + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-INT + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-INT + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 29 & 1344 & 250 \\
    \texttt{chr20} & 49 & 2103 & 375 \\
    \texttt{chr18} & 58 & 2483 & 421 \\
    \texttt{chr16} & 68 & 3092 & 606 \\
    \texttt{chr1} & 150 & 7234 & 1142

  \end{tabular}
\end{table}
\dc{Controllare tutti questi dati}

\subsection{Tempo di una singola query}
Infine, per completare lo studio delle prestazioni dal punto di vista del tempo
macchina, si è deciso di 
isolare il calcolo degli $\SMEM$ per ogni singola query, valutando media e
deviazione standard dell'esecuzione su 100 query. A tal fine, la misurazione è
stata 
effettuata sfruttando la libreria \texttt{time.h} presente nello standard del
linguaggio C, al fine di avere le medesime istruzioni per le misurazioni sia con
la $\PBWT$ 
che con la $\RLPBWT$. La misurazione è stata fatta misurando unicamente le
istruzioni atte a cercare gli $\SMEM$, 
escludendo quelle per il computo degli indici o del caricamento delle strutture
dati.
Si segnala che, nel caso dell'algoritmo \texttt{matchDynamic}, non si è
potuto, per natura stessa dell'algoritmo, isolare il computo degli indici
all'avanzamento alla colonna successiva. Resta esclusa, in ogni caso, la
costruzione della struttura base della $\PBWT$.
\dc{Non se dire questa cosa}
\\
Tale risultato è visualizzabile in figura
\ref{fig:smemsinglechr}, dove si è deciso di escludere le strutture
\texttt{MAP-INT + RLCP} e \texttt{MAP-BV + RLCP} in quanto non in grado di
computare quali righe presentino un certo $\SMEM$. I risultati
quantitativi sono consultabili in tabella \ref{tab:exetimesingle}. Anche in
questo caso, 
si conferma molto di quanto ipotizzato e discusso nel Capitolo
\ref{metchap} e nella sezione precedente. Caso a parte
è dato dall'algoritmo \texttt{matchDynamic}, che risulta avere le performance
peggiori, impiegando fino a cento volte il tempo dell'algoritmo 5 di
Durbin, ovvero l'algoritmo \texttt{matchIndexed}. Infatti, per natura stessa
dell'algoritmo,  
le operazioni sono studiate al fine di essere ottimizzate per pannelli di query
e non per una query singola, avendo molte
operazioni che potrebbero essere ottimizzate per il caso della singola
query. Sperimentalmente, si è
osservato che una query o un centinaio di query presentano all'incirca i
medesimi tempi di calcolo. Infatti, prendendo ad esempio il cromosoma 1, si ha
che tale 
algoritmo impiega 93s per il calcolo con 100 query e una media di circa 88s (con
una deviazione standard di ben 7s) per
una singola query. Per quanto riguarda la $\RLPBWT$, con l'uso della
componente \texttt{RA-SLP}, si rilevano gli stessi problemi relativi all'random
access, precedentemente descritti. Questi problemi sono risolti con l'uso della
componente \texttt{RA-BV}. Inoltre, a parità di componenti per il mapping (e
conseguenti componenti per le threshold), l'uso della componente \texttt{LCE}
risulta più lenta dell'uso della componente \texttt{RA-BV}, a causa dei costi di
calcolo delle $\LCE$ query stesse. Tutti questi sono risultati coerenti
con quanto visto nel caso di 100 query, anche in termini di migliori strutture
composte parlando di $\RLPBWT$. Si segnala che, oltre al fatto che non
sono qui misurate le tempistiche di caricamento delle strutture, le acquisizioni
dei dati 
per la singola query sono state ottenute in un momento diverso da quelle per 100
query, avendo, di conseguenza, una non perfetta proporzione tra i risultati
quantitativi delle due fasi di sperimentazione.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{img/exe_time_single_paper.pdf}
  \caption{Tempo medio di esecuzione del calcolo degli $\SMEM$ per una singola
    query. Il grafico di destra è in scala logaritmica e, in entrambi, le
    barre d'errore rappresentano la deviazione standard.}
  \label{fig:smemsinglechr}
\end{figure}

\begin{table}
  \centering
  \caption{Risultati quantitativi dei tempi (secondi) di calcolo degli
    $\SMEM$ su singola query. I risultati sono nella forma ``media $\pm$
    deviazione standard''.}  
  \label{tab:exetimesingle}
  \footnotesize
  \subcaption*{\footnotesize{Tabella A: risultati relativi alla $\PBWT$.}} 
  \begin{tabular}{c||c|c} 
    \textbf{Chr}
    & \textbf{\texttt{matchIndexed}}
    & \textbf{\texttt{matchDynamic}}\\
    \hline
    \hline
    \texttt{chr22} & 0,15 $\pm$ 0,01 & 18,94 $\pm$ 0,58 \\
    \texttt{chr20} & 0,25 $\pm$ 0,01 & 28,90 $\pm$ 1,99 \\
    \texttt{chr18} & 0,33 $\pm$ 0,02 & 37,24 $\pm$ 1,08  \\
    \texttt{chr16} & 0,38 $\pm$ 0,01 & 45,37 $\pm$ 3,49 \\
    \texttt{chr1} & 1,01 $\pm$ 0,10 & 88,73 $\pm$ 7,08
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella B: risultati relativi alle varianti basate
      su 
      matching statistics e bitvector sparsi per la
      $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-BV + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-BV + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-BV + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 0,75 $\pm$ 0,28 & 16,51 $\pm$ 1,34 & 2,92 $\pm$ 0,55\\
    \texttt{chr20} & 1,08 $\pm$ 0,05 & 22,85 $\pm$ 2,21 & 4,57 $\pm$ 0,82\\
    \texttt{chr18} & 1,36 $\pm$ 0,05 & 27,23 $\pm$ 2,50 & 4,96 $\pm$ 0,74 \\
    \texttt{chr16} & 1,54 $\pm$ 0,05 & 38,93 $\pm$ 2,70 & 7,65 $\pm$ 1,14 \\
    \texttt{chr1} & 3,41 $\pm$ 0,07 & 74,54 $\pm$ 3,40 & 12,75 $\pm$ 1,82 
  \end{tabular}
  \vspace{+3mm}
  \subcaption*{\footnotesize{Tabella C: risultati relativi alle varianti basate
      su 
    matching statistics e intvector compressi per la
    $\RLPBWT$.}}
  \vspace{+1mm}
  \begin{tabular}{c||c|c|c} 
    \textbf{Chr}
    & \textbf{\texttt{MAP/THR-INT + RA-BV $\cdots$}}
    & \textbf{\texttt{MAP/THR-INT + RA-SLP $\cdots$}}
    & \textbf{\texttt{MAP-INT + LCE $\cdots$}}\\
    \hline
    \hline
    \texttt{chr22} & 0,24 $\pm$ 0,02 & 13,52 $\pm$ 1,26 & 2,44 $\pm$ 0,54 \\
    \texttt{chr20} & 0,37 $\pm$ 0,03 & 20,55 $\pm$ 2,16 & 3,68 $\pm$ 0,74 \\
    \texttt{chr18} & 0,45 $\pm$ 0,03 & 24,43 $\pm$ 2,38 & 3,62 $\pm$ 0,70 \\
    \texttt{chr16} & 0,54 $\pm$ 0,03 & 30,86 $\pm$ 2,35 & 5,93 $\pm$ 1,01 \\
    \texttt{chr1} & 1,21 $\pm$ 0,06 & 68,22 $\pm$ 3,02 & 11,12 $\pm$ 1,52

  \end{tabular}
\end{table}

% LocalWords:  sottostrutture gigabyte
